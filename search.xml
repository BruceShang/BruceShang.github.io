<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%BE%AE%E4%BF%A1%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%BB%91%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%BC%B9%E6%A1%86%E9%87%8C%E7%9A%84%E6%8C%89%E9%92%AE%E5%93%8D%E5%BA%94%E5%8C%BA%E5%9F%9F%E9%94%99%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>微信ios 6.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fatal: unable to access ' ':Could not resolve host: github.com解决方案]]></title>
    <url>%2F2019%2F06%2F05%2Ffatal%3A%20unable%20to%20access%20'%20'%3ACould%20not%20resolve%20host%3A%20github.com%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一、在终端输入：1sudo vim /etc/resolv.conf 在最后一行增加nameserver 8.8.8.8或者nameserver 114.114.114.114即可。 114.114.114.114和8.8.8.8，这两个IP地址都属于公共域名解析服务DNS其中的一部分 二、114.114.114.114114.114.114.114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS。 三、8.8.8.8 8.8.8.8是GOOGLE公司提供的DNS，该地址是全球通用的，相对来说，更适合国外以及访问国外网站的用户使用。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BD%BF%E7%94%A8Generic%20Webhook%20Trigger%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Jenkins%2BWebHooks%EF%BC%88%E7%A0%81%E4%BA%91%EF%BC%89%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[一、下载插件安装Generic Webhook Trigger插件在“系统设置–插件管理–可选插件”界面搜索：Generic Webhook Trigger，可以看到，点击安装，然后重启。 二、构建触发 三、配置用户和Security 四、配置码云WebHooks 找到WebHooks配置界面，在POST地址框中输入如下格式内容： 1http://&lt;User ID&gt;:&lt;API Token&gt;@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke 12// 例：http://admin:1156a09fc1c858c800a9e88a2c276@107.12.84.144:8082/generic-webhook-trigger/invoke User ID：既是“三（1）”中的User ID，我的是admin API Token：既是“三（1）”中的API Token Jenkins IP地址：就是你的Jenkins的服务器IP地址，这个必须是公网IP地址。 端口：就是Jenkins服务器的端口 测试接口成功 自动发布成功 本文参考文章Jenkins系列1.使用Jenkins搭建前端构建环境2.Jenkins安装插件动态获取git分支3.使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins安装插件动态获取git分支]]></title>
    <url>%2F2019%2F05%2F09%2FJenkins%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96git%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[一、下载插件在管理中选插件，搜索Git Parameter点击安装。 二、参数化配置1、选择项目-设置-General-选择参数化构建过程 &gt; 添加Git Parameter 配置分支信息 2、源码管理配 三、完成 本文转载链接地址Jenkins系列1.使用Jenkins搭建前端构建环境2.Jenkins安装插件动态获取git分支3.使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex 配置安卓开发环境]]></title>
    <url>%2F2019%2F01%2F31%2Fweex-%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1.安装依赖安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： 1brew install node 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 1npm install -g weex-toolkit 2.初始化weex项目12345678// 1.生成项目weex create awesome-app// 2.进入项目cd awesome-app// 3.安装依赖npm install// 4.启动项目npm start 3.调试查看网络请求信息weex-toolkit 还提供了强大的调试功能，只需要执行： 1weex debug 调试详情步骤 4.集成weex到应用 1.安装安卓运行环境JDK 2.安装Android SDK并配置环境变量 这里我是下载了Android Studio编辑器，打开软件的时候在内部会自动安装，只需要耐心等一下。 5.打包安装1weex run android 6.打包$ANDROID_HOME not found !问题这是没有将sdk配置到环境变量中 123456// 进入配置文件vi ~/.zshrc// 将下面代码放入文件中export ANDROID_HOME=/Users/shangzhen/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 这是sdk的安装位置，在这里可以看到。最后千万别忘了最后一步1source ~/.zshrc 配置好之后一定要重新开一个终端执行命令 7.Build failed with an exception 问题解决123456789// 报错信息FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project ':app'.&gt; You have not accepted the license agreements of the following SDK components: [Android SDK Platform 23, Android SDK Build-Tools 23.0.2]. Before building your project, you need to accept the license agreements and complete the installation of the missing components using the Android Studio SDK Manager. Alternatively, to learn how to transfer the license agreements from one workstation to another, go to http://d.android.com/r/studio-ui/export-licenses.html 执行命令解决1$ANDROID_HOME/tools/bin/sdkmanager --licenses 看到这个页面就代表许可证安装完成了 8.执行 weex run android用一个安卓手机，连接到自己的电脑，手机上开启开发调试模式。编译通过，打包安装到真机上的APP效果图：]]></content>
      <categories>
        <category>weex</category>
        <category>native</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins搭建前端构建环境]]></title>
    <url>%2F2019%2F01%2F04%2F%E4%BD%BF%E7%94%A8Jenkins%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前期准备1.CentOS服务器2.Jenkins3.github账号4.Nginx 这里Nginx的配置就不多说了，有兴趣的话可以参考前面的文章同台服务器上nginx配置多个服务站点共用80端口 服务器环境配置 先将Jenkins网站中的Jenkins存储库添加到包管理器中 12wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.reporpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key 下载安装java和git依赖包 12yum install javayum install git 登录服务器生成ssh key12345// 设置提交用户名和邮箱git config --global user.name "xxx"git config --global user.email "xxxx@qq.com"// 开始生成keyssh-keygen -t rsa -C "yourEmail@xxx.com" 一路回车后就成功生成了 测试一下ssh是否能成功使用1ssh github.com 出现下面情况代表可以正常使用 最后：拷贝服务器中的公钥添加到github中 什么是jenkins呢? Jenkins是一个独立的开源自动化服务器，可用于自动执行与构建，测试，交付或部署软件相关的各种任务。Jenkins可以通过本机系统软件包，Docker安装，甚至可以由安装了Java Runtime Environment（JRE）的任何机器独立运行。 安装Jenkins1yum install jenkins Jenkins配置12// 进入Jenkins配置文件地址：vim /etc/sysconfig/jenkins Jenkins配置文件中的几个重要的参数1234JENKINS_HOME="/var/lib/jenkins" // Jenkins存储配置和工作的目录JENKINS_USER="root" // 将字段值修改root权限// 注意：Jenkins默认的端口号是8080，需要修改的可以在这里修改JENKINS_PORT="8082" // Jenkins端口号 启动Jenkins1service jenkins restart 启动成功后我们在浏览器中输入ip地址和端口号，进入解锁页面 输入密码后，继续进入下一步，进入新手页面。 选择第一个推荐插件安装 安装中… 创建管理员用户 实例配置 创建任务 构建一个自由风格的软件项目 安装两个插件系统管理&gt;插件管理&gt;可选插件中搜索并安装，安装成功后需要重启 1234// 部署项目时需要执行node安装依赖1.NodeJS Plugin // 实现jenkins将服务器构建打包好的war包自动发布到应用服务器，并部署运行2.Publish Over SSH 进入 系统管理 =&gt; 系统设置页面配置Jenkins LocationJenkins服务器地址 Publish over SSH配置Publish over SSH 这里有一点容易出错：Jenkins服务器（A）应用服务器（B） 应用服务器（B）上创建~/.ssh文件夹和~/.ssh/authorized_keys文件，并将jenkins服务器(A)的公钥id_rsa.pub中的内容复制到authorized_keys文件 应用服务器上重启ssh服务，service sshd restart 现在jenkins服务器可免密码直接登陆应用服务器 开始任务配置 源码管理的凭据和 api的凭据不是一样的，apiv5的凭据是插件调用码云接口使用的，而源码管理的凭据是jenkins git插件要求的，这&gt; 个凭据格式是用户名密码，如果用的是http的协议需要在凭据管理中再配置一个码云用户名密码的凭据，这样才能选上，如果是ssh 的话&gt; 需要jenkins的机器的ssh key 加入到码云账号中才行 凭据 》系统 》添加域 构建环境系统管理 》全局工具配置 》NodeJS；如果不添加nodejs在下面 NodeJS Installation 中将不会出来内容 构建 选择Send build artifacts over SSH配置 构建后操作 测试一下部署发布 完美部署暂时先写这么多吧，有空会继续更新…Jenkins系列1.使用Jenkins搭建前端构建环境2.Jenkins安装插件动态获取git分支3.使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Yeoman制作自己的脚手架]]></title>
    <url>%2F2019%2F01%2F02%2F%E4%BD%BF%E7%94%A8Yeoman%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[基于generator-vuecli-3-mobile为例 导读面对复杂的 Web 应用的开发，良好的流程和工具支持是必不可少的，可以让日常的开发工作更加顺畅。Yeoman 作为一个流行的工具集，在整合了 Yo、Grunt 和 Bower 等工具的基础上，定义了一个更加完备和清晰的工作流程。通过把一些最佳实践引入到 Web 应用中，有助于创建高质量和可维护的应用。 环境需要安装Nodejs 全局安装yo 1npm install -g yo 安装generator-generator,生成自己需要的generator的基础框架 1npm install -g generator-generator 运行命令开始生成基础代码1yo generator 设置之后 检查一下生成的目录结构 12345678910111213141516.├── generators/│ └── app/│ ├── index.js // 设置项目模板文件│ └── templates/ // 存放模板文件│ └── dummyfile.txt├── .editorconfig├── .gitattributes├── .gitignore├── .eslintrc├── .travis.yml├── .yo-rc.json // 存储项目配置├── package.json├── gulpfile.js├── README.md├── LICENSE 将模板文件放入到 generators/app/templates文件夹后，我们开始编辑 index.js 文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273'use strict';const Generator = require('yeoman-generator');const chalk = require('chalk');const yosay = require('yosay');const glob = require('globby');const path = require('path');module.exports = class extends Generator &#123; prompting() &#123; this.log( yosay(`Welcome to the phenomenal $&#123;chalk.red('generator-test-generator')&#125; generator!`) ); const prompts = [ &#123; type: 'confirm', name: 'someAnswer', message: 'Would you like to enable this option?', default: true &#125;, &#123; type: 'input', name: 'project-version', message: '项目版本号', default: '0.0.1' &#125; ... // 可以根据自己的需要自行配置 ]; return this.prompt(prompts).then(props =&gt; &#123; this.props = props; &#125;); &#125; /** * 写入文件 */ writing() &#123; this._writeRootFiles(); this._writeFolders(); &#125; // 项目中的文件夹内容 _writeFolders() &#123; ['public', 'src'].forEach(floder =&gt; &#123; this.fs.copy( this.templatePath(floder), this.destinationPath(floder) ) &#125;); &#125; // 根目录下的文件 _writeRootFiles() &#123; glob .sync([this.templatePath('*'), this.templatePath('package.json')]) .forEach(file =&gt; &#123; this.fs.copy( this.templatePath(file), this.destinationPath(path.basename(file).replace(/^_/, '')) ) &#125;); this.fs.copyTpl( this.templatePath('package.json'), this.destinationPath('package.json'), this.props ); &#125; /** * 安装方法 */ install() &#123; // 安装 package 安装. this.installDependencies(&#123; bower: false &#125;); &#125;&#125;; 提交到git仓库12345git init // 初始化git add . // 添加所以要提交的文件git commit -m 'first commit' // 添加提交描述git remote add origin https://github.com/BruceShang/generator-vuecli-3-mobile.git // 将文件添加到新仓库地址git push -u origin master // 推送到master分支 发布到npm 登录or注册账号 12345npm publish --access=public// 发布成功后会返回版本号+ generator-vuecli-3-mobile@0.0.4 如何使用1yo vuecli-3-mobile 升级脚手架实际开发中我们难免会多次修改项目，如何升级脚手架呢？ 1.修改项目中package.json里的version版本号 2.重新发布 1npm publish 3.重新安装全局脚手架 1234sudo npm i vuecli-3-mobile@1.0.1 -g// 或者 先卸载之前的安装，再重新安装sudo npm uninstall vuecli-3-mobile -gsudo npm install vuecli-3-mobile -g]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Yeoman</tag>
        <tag>脚手架</tag>
        <tag>自己的脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同台服务器上nginx配置多个服务站点共用80端口]]></title>
    <url>%2F2018%2F12%2F26%2F%E5%90%8C%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8Anginx%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[登录服务器修改主配置文件1vim /etc/nginx/nginx.conf 12345678910111213141516171819http &#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; // 自定义的所有Nginx配置都自动加载到主配置文件中 include /etc/nginx/conf.d/*.conf;&#125; 在 /etc/nginx/conf.d文件中创建一个自己的配置文件 demp.conf 文件 1234567891011121314server &#123; listen 8080; // 端口号 server_name test.com test2.com localhost; // 设置域名 可以写多个，与名之间用空格隔开 location / &#123; root /root/xxx; // 资源文件地址 index index.html index.htm; // 指定入口文件 &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 重启Nginx,发现报错了。1Job for nginx.service failed because the control process exited with error code. See "systemctl status nginx.service" and "journalctl -xe" for details.、 在网上查了一下资料，找到了问题的解决方案： 1.先查看一下日志systemctl status nginx.service 1234567891011121314151617nginx.service - The nginx HTTP and reverse proxy server Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled) Active: active (running) since 三 2018-12-26 19:47:13 CST; 1h 25min ago Process: 18294 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS) Process: 18290 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS) Process: 18289 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS) Main PID: 18296 (nginx) CGroup: /system.slice/nginx.service ├─18296 nginx: master process /usr/sbin/nginx └─18297 nginx: worker process12月 26 19:47:13 instance-8c351jii systemd[1]: Starting The nginx HTTP and reverse proxy.....12月 26 19:47:13 instance-8c351jii nginx[18290]: nginx: the configuration file /etc/ngin...ok12月 26 19:47:13 instance-8c351jii nginx[18290]: nginx: configuration file /etc/nginx/ng...ul12月 26 19:47:13 instance-8c351jii systemd[1]: Failed to read PID from file /run/nginx.p...nt12月 26 19:47:13 instance-8c351jii systemd[1]: Started The nginx HTTP and reverse proxy ...r.Hint: Some lines were ellipsized, use -l to show in full. 2.killall nginx 3.service nginx restart vue项目部署后，发现路由history模式刷新以后出现404，这是因为我们的是单页客户端应用第一种解决方案123456789location /&#123; root /root/xxx; index index.html index.htm; // 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 if (!-e $request_filename) &#123; rewrite ^/(.*) /index.html last; break; &#125;&#125; 第二种解决方案12345location / &#123; root /root/xxx; index index.html index.htm; try_files $uri $uri/ /index.html; // 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。&#125; 官网给出的解决方案 大功告成，问题都解决了。]]></content>
      <categories>
        <category>服务</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 3.x使用配置]]></title>
    <url>%2F2018%2F12%2F24%2Fvue-cli-3-x%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装 Node 版本要求Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。 123npm install -g @vue/cli# ORyarn global add @vue/cli 检查版本是否正确（3.x）1vue --version 如果需要使用旧版本的 vue init 功能，可以全局安装一个桥接工具：1npm install -g @vue/cli-init 创建项目1vue create projectName 这里我选择自定义项目 选择自己项目中需要安装的包，选择后点击‘空格’选中，回车下一步： 输入‘Y’路由使用history模式 选择一个自己喜欢的css预处理器，这里我选择了stylus 选择eslint 标准 保存lint 选择将Babel,postCSS, ESLint配置在专用配置文件中，还是在pakage.json中。 启动项目1npm run serve 启动后可能碰到的问题 问题： 解决方案 如何在webpack中添加的配置呢？ 首先在项目最外层创建一个vue.config.js的文件，configureWebpack选项提供一个对象,该对象将会被 webpack-merge 合并入最终的 webpack 配置。 123456789 module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; 我们习惯了再vue-cli 2.x中配置文件别名，那么在vue-cli 3.x中如何配置？ 还是在vue.config.js 文件中配置chainWebpack对象 12345678910111213const path = require('path')function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; chainWebpack: config =&gt; &#123; config.resolve.alias .set('@', resolve('src')) .set('assets', resolve('src/assets')) .set('views', resolve('src/views')) &#125;&#125; 更多关于vue.config.js文件的配置 总结vue-cli 2.x的时候配置文件都暴露在项目中，对于多人协同开发的项目，开发人员有时候会自主根据自己的意愿进行修改，对于刚入手vue的人来说多人开发很容易把项目改乱，对于管理员维护不方便。以前使用2.x的时候，我都是把项目中的依赖、配置文件单独提出来，抽出一个单独的SDK打成npm包，发到线上。现在vue-cli 3.x已经把这些配置文件都抽成了npm包，同时只预留一些配置入口，着实方便不少，在项目中只需简单的配置就完成了一个项目搭建。]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>vue-cli 3</tag>
        <tag>vue脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5 唤醒App]]></title>
    <url>%2F2018%2F09%2F30%2Fh5-%E5%94%A4%E9%86%92App%2F</url>
    <content type="text"><![CDATA[这里我们来看看scheme拼接协议的格式：&lt; a href=”[scheme]://[host]/[path]?[query]”&gt;启动应用程序&lt; /a&gt; 各个项目含义如下所示： scheme：判别启动的App。 ※详细后述 host：适当记述 path：传值时必须的key ※没有也可以 query：获取值的Key和Value ※没有也可以]]></content>
      <categories>
        <category>h5</category>
        <category>App</category>
      </categories>
      <tags>
        <tag>h5</tag>
        <tag>唤醒App</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli build打包后CSS浏览器兼容前缀自动去除的问题]]></title>
    <url>%2F2018%2F09%2F25%2Fvue-cli-build%E6%89%93%E5%8C%85%E5%90%8ECSS%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E5%89%8D%E7%BC%80%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天做练手项目部署的时候碰到了个奇怪问题，开发环境里显示得好好的CSS prefixer样式，到production环境就消失了。我开发环境用的是 scss ，刚开始我还以为是 scss 处理器的问题，后来研究了下 build 脚本，发现人家把CSS统一用一个插件给压缩了，然后追查之下发现这个插件用了 postCSS 的 autoprefixer 插件。这下问题就清楚了，因为 autoprefixer 插件会针对支持的浏览器进行CSS 前缀的删除和追加。 比如： 1234a &#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 编译成： 123a &#123; border-radius: 5px;&#125; autoprefixer 使用了 browserslist 作为依赖。在项目目录中运行: 1npx browserslist 可以查看当前项目支持的浏览器列表，这时候只要修改当前项目支持的浏览器就可以了。vue-cli生成的项目默认支持部分移动端浏览器和最新版本的PC端浏览器。 在 package.json 中修改 browserslist 12345678"browserslist": [ "&gt; 1%", "last 2 versions", "last 10 Chrome versions", "last 5 Firefox versions", "Safari &gt;= 6", "ie &gt; 8"] 如果是h5移动端项目中需要兼容iPhone 5 （ios8）的需要如下配置： 12345678910"browserslist": [ "&gt; 1%", "last 2 versions", "last 10 Chrome versions", "last 5 Firefox versions", "Safari &gt;= 6", "ie &gt; 8", "ios &gt;= 7", "android &gt;= 4.3"], 之后再运行 npm run build 这时生成的代码就有 css prefix 了。 博客原文：http://www.zhuyuwei.cn/2018/vue-cli-css-prefixer.html]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
        <tag>h5中ios8兼容问题</tag>
        <tag>vue-cli打包后css前缀自动去除问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue项目中使用百度分享]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[环境：在vue项目中使用html部分123456789&lt;div class="share__wrap"&gt; &lt;div class="share__content"&gt; &lt;div class="bdsharebuttonbox col-xs-5 share__wrapper"&gt; &lt;a class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"&gt;分享到QQ空间&lt;/a&gt; &lt;a class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"&gt;分享到新浪微博&lt;/a&gt; &lt;a class="bds_renren" data-cmd="renren" title="分享到人人网"&gt;分享到人人网&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; js部分1234567891011121314151617181920212223242526272829303132/** * 顶部分享 * @param &#123;string&#125; img - 图片地址 * @param &#123;string&#125; text - 文本提示 * @param &#123;string&#125; desc - 描述 */const share = (img, text, desc) =&gt; &#123; const url = document.location.href window._bd_share_config = &#123; common: &#123; bdSnsKe: &#123;&#125;, bdMini: '2', bdStyle: '0', bdSize: '32', bdUrl: url, bdPic: img, bdText: text, bdDesc: desc, &#125;, share: &#123;&#125;, selectShare: &#123; bdContainerClass: null, bdSelectMiniList: ['qzone', 'tsina', 'popup_tqq', 'renren'], viewSize: '32', &#125;, &#125; const bdScript = document.createElement('script') bdScript.setAttribute('src', `http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion=$&#123;new Date().getTime()&#125;`) document.getElementsByTagName('head')[0].appendChild(bdScript)&#125;export default share 分享媒体id对应表123456789101112131415161718192021222324252627282930313233343536373839404142名称 ID印象笔记 evernotecn网易热 h163一键分享 mshareQQ空间 qzone新浪微博 tsina人人网 renren腾讯微博 tqq百度相册 bdxc开心网 kaixin001腾讯朋友 tqf百度贴吧 tieba豆瓣网 douban百度新首页 bdhomeQQ好友 sqq和讯微博 thx百度云收藏 bdysc美丽说 meilishuo蘑菇街 mogujie点点网 diandian花瓣 huaban堆糖 duitang和讯 hx飞信 fx有道云笔记 youdao麦库记事 sdo轻笔记 qingbiji人民微博 people新华微博 xinhua邮件分享 mail我的搜狐 isohu摇篮空间 yaolan若邻网 wealink天涯社区 tyFacebook fbookTwitter twilinkedin linkedin复制网址 copy打印 print百度中心 ibaidu微信 weixin股吧 iguba]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>百度分享</tag>
        <tag>bdshare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F08%2F28%2Fweb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化1.减少http请求 1.图片 2.样式 3.脚本 2.压缩组件 前端 1.css文件 and js脚本的内容压缩，图片压缩服务端 1.启用GZIP编码来压缩http响应包的大小。通过HTTP请求中的Accept-Encoding头来标识对压缩的支持 1Accept-Encoding: gzip,deflate 3.样式表放在顶部4.将脚本放在底部5.避免css表达式例如：1width:expression(setCntr(),document.body.clientWidth&lt;600?"600px":"auto"); 6.精简JavaScript例如：避免使用过多额全局遍历，避免过多的dom操作,缓存查找到的DOM元素 7.配置ETagETag 全称为：Entity Tag，意思是实体标签。 作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）来请求的时候，可以比较，如果ETag一致，则表示该资源并没有修改过，客户端（浏览器）可以使用自己缓存的版本。最终目的：缓存内容减少HTTP请求。 8.使Ajax可缓存使Ajax可缓存的前提是保证你的数据是不经常变化的，如果发生变化就重新从服务器请求新的数据 关于Ajax，我建议通过Ajax请求的内容仅包含必须从服务端返回的数据信息，HTML结构部分则缓存到HTML页面当中，然后通过模版解析，把所通过ajax请求的内容展示出来，因为目前浏览器端的运算速度越来越快了，所以现在完全可以这样做。 9.http缓存分类 强制缓存 在缓存数据未失效的情况下，不需要再和服务器发生交互 Expires 我们在demo.js中添加了一个Expires响应头，不过由于是格林尼治时间，所以通过momentjs转换一下。第一次请求的时候还是会向服务器发起请求，同时会把过期时间和文件一起返回给我们；但是当我们刷新的时候，才是见证奇迹的时刻：可以看出文件是直接从缓存（memory cache）中读取的，并没有发起请求。我们在这边设置过期时间为两分钟，两分钟过后可以刷新一下页面看到浏览器再次发送请求了。 虽然这种方式添加了缓存控制，节省流量，但是还是有以下几个问题的： 由于浏览器时间和服务器时间不同步，如果浏览器设置了一个很后的时间，过期时间一直没有用缓存过期后，不管文件有没有发生变化，服务器都会再次读取文件返回给浏览器 不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。 Cache-Control针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。 123456app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js'); let cont = fs.readFileSync(jsPath); res.setHeader('Cache-Control', 'public,max-age=120') //2分钟 res.end(cont)&#125;) 协商缓存需要进行比较判断是否可以使用缓存 强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。 Last-Modified为了节省服务器的资源，再次改进方案。浏览器和服务器协商，服务器每次返回文件的同时，告诉浏览器文件在服务器上最近的修改时间。请求过程如下： 浏览器请求静态资源demo.js服务器读取磁盘文件demo.js，返给浏览器，同时带上文件上次修改时间 Last-Modified（GMT标准格式）当浏览器上的缓存文件过期时，浏览器带上请求头If-Modified-Since（等于上一次请求的Last-Modified）请求服务器服务器比较请求头里的If-Modified-Since和文件的上次修改时间。如果果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和Last-Modified。循环请求。。12345678910111213141516app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js') let cont = fs.readFileSync(jsPath); let status = fs.statSync(jsPath) let lastModified = status.mtime.toUTCString() if(lastModified === req.headers['if-modified-since'])&#123; res.writeHead(304, 'Not Modified') res.end() &#125; else &#123; res.setHeader('Cache-Control', 'public,max-age=5') res.setHeader('Last-Modified', lastModified) res.writeHead(200, 'OK') res.end(cont) &#125;&#125;) 虽然这个方案比前面三个方案有了进一步的优化，浏览器检测文件是否有修改，如果没有变化就不再发送文件；但是还是有以下缺点： 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件如果服务器上文件被多次修改了但是内容却没有发生改变，服务器需要再次重新返回文件。 ETag浏览器请求静态资源demo.js服务器读取磁盘文件demo.js，返给浏览器，同时带上文件的唯一标识ETag当浏览器上的缓存文件过期时，浏览器带上请求头If-None-Match（等于上一次请求的ETag）请求服务器服务器比较请求头里的If-None-Match和文件的ETag。如果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和ETag。循环请求。。12345678910111213141516const md5 = require('md5');app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js'); let cont = fs.readFileSync(jsPath); let etag = md5(cont); if(req.headers['if-none-match'] === etag)&#123; res.writeHead(304, 'Not Modified'); res.end(); &#125; else &#123; res.setHeader('ETag', etag); res.writeHead(200, 'OK'); res.end(cont); &#125;&#125;) 缓存的优先级两种缓存规则可以同时存在，强制缓存优先级高于协商缓存。Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified参考资料 前端也要懂Http缓存机制]]></content>
      <categories>
        <category>ssh key</category>
      </categories>
      <tags>
        <tag>web性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在同一台Mac上，使用多个邮箱，配置多个ssh key]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8F%B0Mac%E4%B8%8A%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E9%82%AE%E7%AE%B1%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key%2F</url>
    <content type="text"><![CDATA[前言介绍 自己开始用自己的邮箱，注册了ssh key，将公钥添加到了github上，但现在公司要求使用企业邮箱生成公钥，将使用公司的企业邮箱生成的公钥添加到自己公司搭建的gitlab私服上，由此以来开始了下面的折腾。同时使用多个邮箱，注册多个公钥。 1.先使用自己的邮箱生成第一个key12// 在终端中执行ssh-keygen -t rsa -C "yourEmail@xxx.com" 第一个key一路回车,生成以后，在终端中执行下面命令进行查看 1open ~/.ssh 此时，.ssh文件中多个两个文件 id_rsa 私钥，id_rsa.pub 2.在使用公司邮箱生成第二个key12// 在终端中执行ssh-keygen -t rsa -C "companyEmail@xxx.com" 回车以后：在下面的操作中，给第二个key取一个名字，用于区分。如果一路回车会覆盖掉第一次生成的秘钥。 1Enter file in which to save the key (/Users/Shinancao/.ssh/id_rsa): id_rsa_customName 现在，再执行命令 open ~/.ssh命令，我们能看到 .ssh文件中又多了两个秘钥 3.在.ssh文件夹中创建一个config文件 1vim ~/.ssh/config 配置config 12345678910111213141516# githubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser github注册的用户名# custome-gitlabHost company // 别名HostName 192.168.11.XXX // 公司服务器ipport 10080 // 端口号PreferredAuthentications publickey // 强制使用Public Key验证IdentityFile ~/.ssh/id_rsa_nyso // 密钥文件的路径User 注册的用户名 4.使用的过程会报错，那是因为我们还没有加载刚才的配置1234567//查看当前rsa listssh-add -l //如果列表中没有新增的rsa， 添加identifilessh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_customName// 再去操作就没有问题了 5.设置全局的用户名和邮箱12git config --global user.name "your name"git config --global user.email "your email" 6.查看配置的结果12git config --global user.namegit config --global user.email 7.设置全局后默认都是，全局配置用户名和邮箱。如果我们想针对不同的仓库，使用不同的用户名和邮箱呢？1234567891011// 先取消全局设置git config --global --unset user.namegit config --global --unset user.email// 再进入项目目录下设置git config user.email "your name"git config user.email "your email"// 查看配置结果git config user.namegit config user.email 8.大功告成，可以下班回家喽。😁]]></content>
      <categories>
        <category>ssh key</category>
      </categories>
      <tags>
        <tag>ssh key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac电脑上使用tree生成目录结构]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%9C%A8Mac%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8tree%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[生成markdown文件的目录结构，先上效果图12345678910111213141516171819202122232425262728293031323334353637383940.├── build│ ├── build.js│ ├── check-versions.js│ ├── logo.png│ ├── utils.js│ ├── vue-loader.conf.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── index.html├── package.json├── src│ ├── api│ │ └── index.js│ ├── assets│ │ ├── images│ │ └── stylus│ ├── components│ │ ├── checkbox│ │ ├── index.js│ │ ├── radio│ │ └── topbar│ ├── index.js│ ├── main.js│ ├── mixins│ ├── router│ │ ├── index.js│ │ └── routes│── └── views│ ├── App.vue│ ├── index│ └── ui├── static│ └── .gitkeep└── tree.md 1. Mac下使用brew install tree进行安装。安装之后在终端里，输入 tree -a 就可以查看当前目录下的缩影文件。 使用brew的时候，每次都会进行检查更新。每次更新特别慢，怎么把它给禁掉呢 1export HOMEBREW_NO_AUTO_UPDATE=true 在终端中执行这行代码后就能禁掉，现在试试就不再自动更新了。 2. tree的常用命令行参数 -a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用”?”号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 3. 我们根据自己的项目来实际操作一下1tree -L 3 -I "node_modules" &gt; tree.md 上面命令意思是显示项目下3层的所有文件结构，同时忽略node_modules文件夹，最后输出到tree.md]]></content>
      <categories>
        <category>tree</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建自己的npm包]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85%EF%BC%8C%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[为什么要使用NPM NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功: 15.6.0 1. 先在本地构建一个demo的项目，创建index.js文件1234// index.jsmodule.exports.helloWorld = function() &#123; return 'Hello World!'&#125; 2. npm 初始化创建package.json文件1npm init 3. 先在npmjs官网上注册一个自己的账号 注册成功后，打开命令行工具。1npm login 根据命令提示输入用户名密码，登录后可以查询自己的账号 1npm whoami 4. 这些做完准备工作就都准备完了，现在开始上传npm包 cmd进入demo目录，执行下面命令1npm publish 如果第一次名称没有冲突和符合npm命名规范的话，就直接上传成功了 特别注意，每次发包都要更改版本号 5.使用npm包1234// 先安装刚刚上传的包npm i test-package-name --save-dev// 再引用let test = require('test-package-name') 6.定义作用于模块 防止构建新包命名时和别人的重复，造成发布失败。我们使用自己的用户名定义一个作用域，每个npm用户都有一个以自己名为作用域。 1@username/project-name 7.发布作用模块1@username/project-name 报错了，什么鬼。 原来携带头的npm作用域默认发的是私有包，要想成功发包，添加access=public参数，发布成为公用包 1npm publish --access=public]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTem2 + oh my zsh + agnoster 打造自己的终端工具]]></title>
    <url>%2F2018%2F07%2F06%2FiTem2-oh-my-zsh-agnoster-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1. 安装iTem2iTerm2传送门，选择要下载的安装包 2. oh-my-zsh介绍 oh-my-zsh是基于zsh的功能做了一个扩展，方便的插件管理、主题自定义，以及漂亮的自动完成效果 安装zsh12brew install zsh// 出现这个画面后就代码安装成功 没有安装homebrew的先安装一下homebrew官网 复制下面命令，在终端中输入：1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" brew 安装插件的时候默认都会进行更新，这个是特别慢的毕竟有道墙，手动设置关闭自动更新，在终端中执行下面代码。 1export HOMEBREW_NO_AUTO_UPDATE=true 查看当前默认bash，修改默认shell1chsh -s /bin/zsh 修改完之后验证是否修改成功12echo $SHELL// 此时终端打印出 /bin/zsh 恭喜你设置成功 下载安装PowerFonts字体123456# git clonegit clone https://github.com/powerline/fonts.git --depth=1# cd to foldercd fonts# run install shell./install.sh 安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好： 配置agnoster主题安装成功之后，我们可以通过vi ~/.zshrc，设置ZSH_THEME=”agnoster”对主题进行修改。 最终效果图 命令补全123456789cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-autosuggestionsvi ~/.zshrc// 找到plugins，修改内容plugins=( git zsh-autosuggestions)// 默认打开里面已经有一个git 效果展示 安装高亮插件123456789cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitvi ~/.zshrc// 找到plugins，修改内容plugins=( git zsh-autosuggestions zsh-syntax-highlighting) zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：1source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 按一下esc调出vi命令，输入:wq保存并退出vi模式。 执行命令使刚才的修改生效：1source ~/.zshrc 配置完成]]></content>
      <categories>
        <category>iTem2</category>
      </categories>
      <tags>
        <tag>iTem2</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.创建数组的两个基本方式1234// 1. 使用Array构造函数let person = new Array()// 2. 使用字面量表示法let person = ['name', 'age'] 2. 判断是否为数组类型123456789// 1. 使用instanceof判断let num = [1, 3, 5, 7]console.log(num instanceof Array) // true// 2. constructor 判断console.log(num.constructor === Array) // true// 3. 现获取内部的属性，返回一个字符串，再利用call，达到检测数组的目的,综合考虑推荐这种写法console.log(Object.prototype.toString.call(num) === '[object Array]') // true// 4. Array.isArrayconsole.log(Array.isArray(num)) // true 3. 数组中的常用方法(只列出常用的) push() pop() unshift() shift() splice()1234567891011121314151617181920212223242526272829303132333435// push()方法可以接受任意参数，逐个添加到数组尾部，并返回添加后的数组长度，该数组也会修改原数组。let arr = [1]console.log(arr.push(2)) // arr =&gt; [1, 2]console.log(arr.push('three')) // arr =&gt; [1, 'three']console.log(arr.push(&#123; a: 3 &#125;)) // arr =&gt; [1, &#123; a: 3 &#125;]console.log(arr.push([2, 3])) // arr =&gt; [1, [2, 3]]// pop() 从数组末尾移除最后一项，减少数组的长度，然后返回移除的项，并且会改变原来的数组let brow = ['Google', 'Baidu', '360']console.log(brow.pop()) // brow =&gt; ['Google', 'Baidu']// shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。let arr = [1, 3, 5, 7]console.log(arr.shift()) // arr =&gt; [3, 5, 7]/* * splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 * array.splice(start, deleteCount, item1,...itemX) * start :必须 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始* 的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的* 元素。 * deleteCount 可选 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如* 果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 * item1...itemX 可选要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 */ let arr = [1, 2, 3, 4, 5, 6, 7]// 从第2位开始删除0个元素，插入“drum” arr.splice(2, 0, 'a') //arr =&gt; [1, 2, "a", 3, 4, 5, 6, 7]// 从第3位开始删除1个元素arr.splice(3, 1) //arr =&gt; [1, 2, 3, 5, 6, 7]// 从第2位开始删除1个元素，然后插入“temp”arr.splice(2, 1, 'temp') //arr =&gt; [1, 2, 'temp', 4, 5, 6, 7]// 从第0位开始删除2个元素，然后插入"a1","a2"和"a3"arr.splice(0, 2, 'a1', 'a2', 'a3') //arr =&gt; ['a1', 'a2', 'a3', 3, 4, 5, 6, 7]// 从第2位开始删除2个元素arr.splice(arr.length - 3, 2) // arr =&gt; [1, 2, 5, 6, 7]// 从第2位开始删除所有元素arr.splice(2) // arr =&gt; [1, 2] 4. 可能遇到的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 将数组中的数字相加求和let arr = [1, 2, 3, 4, 5, 6, 7]console.log(eval(arr.join('+')))// 模拟后端返回的数据格式let result = &#123; code: '200', data: [ &#123; id: 123, name: 'a1', age: 25 &#125;, &#123; id: 456, name: 'a2', age: 26 &#125;, &#123; id: 789, name: 'a3', age: 27 &#125; ]&#125;// 判断后端返回数据中是否存在id为456的数据const filter1 = function(id) &#123; let obj = [] const data = result.data data.forEach((item) =&gt; &#123; let id = item.id obj.push(id) &#125;) return obj.indexOf(id) &gt; -1 ? true : false&#125;filter1(456) // =&gt; truefilter1(4566) // =&gt; false// 获取id为456的数据const filterData = function (id) &#123; let obj = &#123;&#125; const data = result.data data.forEach((item) =&gt; &#123; let id = item.id obj[id] = item &#125;) return obj[id] ? obj[id] : []&#125;filterData(456) // =&gt; &#123;id: 456, name: "a2", age: 26&#125;filterData(4566) // =&gt; []]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue脚手架vue-cli配置多页面应用]]></title>
    <url>%2F2018%2F05%2F05%2Fvue%E9%A1%B9%E7%9B%AEwebpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[webpack常用插件 html-webpack-plugin // 生成一个html文件 clean-webpack-plugin // 清除dist文件夹中重复的文件 webpack-merger // 合并webpack配置文件 webpack-dev-server // 热启动 extract-text-webpack-plguin // 抽取样式文本 1.配置多入口123456789101112131415161718192021222324// utils.js// 查找符合特定规则的文件路径名var glob = require('glob')//获取多级的入口文件exports.getMultiEntry = function (globPath) &#123; var entries = &#123;&#125;, basename, tmp, pathname; glob.sync(globPath).forEach(function (entry) &#123; basename = path.basename(entry, path.extname(entry)); tmp = entry.split('/').splice(-4); var pathsrc = tmp[0] + '/' + tmp[1]; if (tmp[0] == 'src') &#123; pathsrc = tmp[1]; &#125; pathname = pathsrc + '/' + basename; // 正确输出js和html的路径 entries[pathname] = entry; &#125;); return entries;&#125; 2. 在webpack.base.conf.js中赋值给entry123456const utils = require('./utils')// 多页面设置入口文件const entries = utils.getMultiEntry('./src/' + config.moduleName + '/**/**/*.js');module.exports = &#123; entry: entries,&#125; 3. 构建生成多页面的HtmlWebpackPlugin配置12345678910111213141516// webpack.dev.conf.js webpack.prod.conf.js分别在webpack.dev.conf.js 和webpack.prod.conf.js中设置var pages = utils.getMultiEntry('./src/' + config.moduleName + '/**/**/*.html');for (var pathname in pages) &#123; var conf = &#123; filename: pathname + '.html', template: pages[pathname], // 模板路径 chunks: ['vendor', pathname], // 每个html引用的js模块 inject: true, // js插入位置 hash: true &#125;; webpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125;module.exports = webpackConfig 4. 简单的几步走，具体细节看项目代码使用vue脚手架vue-cli配置多页面应用]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Object]]></title>
    <url>%2F2018%2F02%2F01%2Fobject%2F</url>
    <content type="text"><![CDATA[1.创建对象的几种方法1.1创建对象的最简单的方法就是使用对象直接量1var emptyObj = &#123;&#125;; 1.2 通过new创建对象1var emptyObj = new Object(); 1.3 Object.create(prototype, [propertyObject])使用Object.create()创建一个新对象，其中第一个参数是对象的原型，第二个是可选参数，用于对对象的属性进行进一步的描述。propertyObject 为null时新创建的对象就不包括所有的属性和方法 var obj = Object.create(null) obj.toString =&gt; undefined Object.create应用场景(实现继承)1234567891011121314function Person() &#123;&#125;function Student() &#123;&#125; // 这样做的好处是修改子类的属性不会对父类造成影响，可以在Student实现自己的属性和方法，但有一点Object.create是ES5的时候才有的方法，不兼容低版本，如果想要使用Object.create可以事先判断一下Student.prototype = Object.create(Person.prototype)if (!Object.create) &#123; Object.create = function (proto) &#123; function N () &#123;&#125; N.prototype = proto; return N; &#125;&#125;// 对上面的继承进行扩展，有一种更加便利的方式;// 将Student原型对象中的构造函数指向PersonStudent.prototype.constructor = Person 对象中的getter setter方法1234567891011121314151617181920212223242526272829303132var objs = &#123; name: 'Bruce', get deelName() &#123; return this.name &#125;, set deelName(val) &#123; this.name = val &#125;&#125;// 获取属性值 objs.deelName =&gt; Bruce// 为对象属性赋值 objs.deelName = 'test'// 验证赋值=&gt; 'test'// objs.name =&gt; 'test'// 对象已有的属性添加特性描述var book = &#123; _year: 2004,&#125;Object.defineProperty(book, 'year', &#123; configurable: true, // 默认为true 是否可以配置（删除、修改、访问） enumerable: true, // 默认true 是否能枚举for-in writable: true, // 默认true 是否能修改属性的值 get: function() &#123; return this._year &#125;, set: function(newval) &#123; this._year = newval &#125;&#125;)// book.year =&gt; 2004// book.year = 2005// book.year =&gt; 2005]]></content>
      <categories>
        <category>Object</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum操作常用命令]]></title>
    <url>%2F2018%2F01%2F31%2Fyum-not%2F</url>
    <content type="text"><![CDATA[列出所有已安装的软件包1yum list installed yum针对软件包操作常用命令：1.使用YUM查找软件包1yum search 2.列出所有可安装的软件包1yum list 3.列出所有可更新的软件包1yum list updates 4.列出所有已安装的软件包1yum list installed 5.列出所有已安装但不在 Yum Repository 内的软件包1yum list extras 6.列出所指定的软件包1yum list 7.使用YUM获取软件包信息1yum info 8.列出所有软件包的信息1yum info 9.列出所有可更新的软件包信息1yum info updates 10.列出所有已安装的软件包信息1yum info installed 11.列出所有已安装但不在 Yum Repository 内的软件包信息1yum info extras 12.列出软件包提供哪些文件1yum provides]]></content>
      <categories>
        <category>yum</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F01%2F29%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.命令的基本格式命令 选项 参数 ls -a 全部文件/包括隐藏文件 ls -l 显示详细信息ls -d 查看目录属性ls -i 显示inodels -lh 显示文件的字节大小 rw -r - - r - - 文件类型 （ - 文件 d 目录 i软链接文件）rw- r - - r - -u所有者 g所属组 o其他人r 读 w写 x执行 2.目录处理命令根目录和家目录是两个不同的概念 mkdir -p 目录-p 递归创建 cd+enter 进入当前用户的家目录cd ~ 进入当前用户的家目录cd - 进入上次目录cd .. 进入上一级目录cd . 进入当前目录 相对路径：参照的是我当前的目录绝对路径：具体的目标路径 按连续两次tab键：命全补充和目录补全pwd：打印当前位置的工作路径 3.删除文件或目录rm -rf 文件/目录 -r 删除目录-f 强制 4.复制文件或目录cp -r 原文件或目录 目标目录 -p 连带文件属性复制 -d 若源文件是链接文件，则复制链接属性 -a 相当于pdr 5.剪切或者改名命令mv 源文件或者目录 目标目录 6.目录介绍根目录下的bin和sbin， usr目录下的bin和sbin，这四个目录都是用来保存系统命令的。bin和sbin的区分：bin： 任何用户都可以执行sbin：只有root用户才能执行boot: 启动目录dev: 特殊文件保存目录lib: 函数库目录sys 和 proc: proc和sys目录不能直接操作，这两个目录保存的是内存的过载点。usr：系统软件资源目录var：系统相关命令media met misc 空目录 7.文件搜索命令 文件搜索命令locate(执行没有命令执行时需要安装 yum install locate)locate 文件名在后台数据库中按文件名搜索，搜索速度更快 /var/lib/mlocatelocate命令所搜索的后台数据库 updated更新数据库/etc/updatedb.conf 配置文件 命令搜索命令whereis与which whereis 命令名搜索命令所在路径及帮助文档所在位置 -b: 只查找可执行文件-m:只查找帮助文件 which 命令名 搜索命令所在路径及别名 文件搜索命令find find 搜索范围 搜索条件find / -name filelog.log find 是在系统中搜索符合条件的文件名，如果需要匹配，s会用通配符匹配，通配符是完全匹配。 find / -iname filelog.log 加i忽略大小写 find / -user root 按照所有者搜索 Linux中的通配符 匹配任意内容？匹配任意一个字符[] 匹配任意一个中括号内的字符]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac环境下使用瓶子（Charles）抓包Https请求]]></title>
    <url>%2F2017%2F12%2F19%2FCharles%2F</url>
    <content type="text"><![CDATA[Charles 根证书配置1.选择 Charles 菜单“Help”-&gt;“SSL Proxying”-&gt;“Install Charles Root Certificate”2.接着会自动弹出‘钥匙串访问’，默认情况下 Charles Proxy CA证书不会被信任的，右键选择显示简介将证书修改为始终信任 SSL Proxying Settings选择菜单中“Proxy”-&gt;“SSL Proxying Settings…”添加使用通配符 Host Port ，表示抓取所有地址与端口的HTTPS请求 给手机安装证书 设置手机代理（IP地址为电脑ip），端口号为Proxy &gt; Proxies &gt; HTTP Proxy 中设置的端口号 打开Charles，在Menu选择Help &gt; SSL Proxying &gt; Install Charles Root Certificate on a Mobile Device or Remote Browse弹出一个弹框，根据提示使用手机访问地址： chls.pro/ssl 给手机安装证书 安卓手机需要注意（Android设备安装.pem证书文件） Android设备，只有部分设备的默认浏览器会识别.pem这个格式，而其他浏览器和一些机型不能自己安装这个文件。需要在设置中找到，类似于 安全与隐私，这一项，然后从存储设备中安装。 最后别忘了在手机中将瓶子证书设置为信任，不然请求就会一直返回unknown设置–&gt;通用–&gt;关于本机–&gt;证书信任设置把里面的那个Charles的证书设置为信任就可以了]]></content>
      <categories>
        <category>Charles</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>mac Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm常用操作]]></title>
    <url>%2F2017%2F11%2F17%2Fnvm%2F</url>
    <content type="text"><![CDATA[1.安装nvm命令github.com nvm wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 2.核实nvm是否安装成功，安装成功后执行命令返回’nvm’1command -v nvm 3.检查当前支持什么版本1nvm ls-remote 4.指定安装版本1nvm install vx.x.x 5.安装最新稳定版本1nvm install stable 6.删除某版本的node12nvm uninstall 4.4.0nvm uninstall default 7.nvm使用default的alias来实现默认版本,执行命令1nvm alias default vx.x.x 8.查看当前已经安装的版本1nvm ls 9.以指定版本执行脚本1nvm use v8.8.1 app.js 10.卸载nvm1rm -rf ~/.nvm 11.切换至x.x.x版本1nvm use vx.x.x 12.查看正在使用的版本1nvm current]]></content>
      <categories>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>mac nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac电脑终端使用scp上传/下载文件/文件夹]]></title>
    <url>%2F2017%2F11%2F15%2Fremote-scp%2F</url>
    <content type="text"><![CDATA[1.从服务器下载文件到本地电脑1scp -r remote_username@remote_ip:remote_folder local_folder 例如： 1scp -r root@106.xx.xxx.xx:/root/www/file /Desktop/folder 2.从本地上传文件到服务器1scp -r local_folder remote_username@remote_ip:remote_folder 例如： 1scp -r /Desktop/folder root@106.xx.xxx.xx:/root/www/file 3.上传和下载文件就是把这种格式来回调换一下]]></content>
      <categories>
        <category>scp</category>
      </categories>
      <tags>
        <tag>scp</tag>
        <tag>mac scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用mac终端将本地文件上传到服务器上]]></title>
    <url>%2F2017%2F11%2F15%2Fremote-shell%2F</url>
    <content type="text"><![CDATA[1.打开本地终端，使用菜单中Shell2.使用菜单中Shell 选择 “新建远程连接”3.进入“新建远程连接控制面板”后左侧服务选择“安全文件传输（sftp）”右侧服务器端添加自己的服务器连接ip地址，同时输入要使用的“用户”身份选择登录。4.开始上传本地文件，上传文件之前需要把文件在本地进行压缩 put 本地文件的地址链接 要上传到服务器的位置 1put Desktop/www/file.zip /www/file 5.在服务上对已上传的压缩文件进行解压 切换到文件当前目录下执行命令： 1unzip file.zip]]></content>
      <categories>
        <category>mac</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>mac shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express 路由(Router)]]></title>
    <url>%2F2016%2F10%2F29%2Fexpress-router%2F</url>
    <content type="text"><![CDATA[基本路由1.路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。路由定义采用以下结构： 1app.METHOD(PATH, HANDLER) 其中：app 是 express 的实例。METHOD 是 HTTP 请求方法。PATH 是服务器上的路径。HANDLER 是在路由匹配时执行的函数。 2.在根路由 (/) 上（应用程序的主页）对 POST 请求进行响应：123app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user');&#125;); 有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。在以下示例中，无论您使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法，都将为针对“/secret”的请求执行处理程序。 1234app.all('/secret', function (req, res, next) &#123;console.log('Accessing the secret section ...');next(); // pass control to the next handler&#125;); 路由路径路由路径与请求方法相结合，用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。 Express 使用 path-to-regexp 来匹配路由路径；请参阅 path-to-regexp 文档以了解定义路由路径时所有的可能性。Express Route Tester 是用于测试基本 Express 路由的便捷工具，但是它不支持模式匹配。 以下是基于字符串的路由路径的一些示例。 此路由路径将请求与根路由 / 匹配。 123app.get('/', function (req, res) &#123; res.send('root');&#125;); 此路由路径将请求与 /about 匹配。 123app.get('/about', function (req, res) &#123; res.send('about');&#125;); 字符 ?、+、* 和 () 是其正则表达式同应项的子集。基于字符串的路径按字面理解连字符 (-) 和点 (.)。 express.Router使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。 以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。 在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容： 12345678910111213141516var express = require('express');var router = express.Router();// middleware that is specific to this routerrouter.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// define the home page routerouter.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// define the about routerouter.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 接着，在应用程序中装入路由器模块：123var birds = require('./birds');...app.use('/birds', birds); 此应用程序现在可处理针对 /birds 和 /birds/about 的请求，调用特定于此路由的 timeLog 中间件函数。]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>express.Router</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue filter]]></title>
    <url>%2F2016%2F10%2F10%2Fvue-filter%2F</url>
    <content type="text"><![CDATA[Vue过滤器的基本使用html部分123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--插值中的表达式--&gt; &lt;input type="text" v-model="msg"&gt; &lt;h2&gt;&#123;&#123; msg ? 'YES' : 'NO' &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; msg.split('').reverse().join('') | uppercase &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; number + 1 | currency '₫' 0 &#125;&#125;&lt;/h2&gt; &lt;!--自定义过滤器--&gt; &lt;h2&gt; &#123;&#123; filterParam | customFilter&#125;&#125;&lt;/h2&gt; &lt;!-- 1.limitBy - test 2.限制只显示数字中前两条数据 --&gt; &lt;ul&gt; &lt;li v-for="item in dataArray | limitBy 2"&gt;name: &#123;&#123; item.name &#125;&#125;----age: &#123;&#123; item.age &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 1.filterBy - test 2.过滤出对象中name属性字段含有‘Chuck’值的数据，并且只显示该数据 3.in 后面可以跟多字段进行搜索 --&gt; &lt;ul&gt; &lt;li v-for="item in dataArray | filterBy 'Chuck123' in 'name' 'temp'"&gt;name: &#123;&#123; item.name &#125;&#125;----age: &#123;&#123; item.age &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; js部分12345678910111213141516171819202122/** * 1.split 将字符串分割成数组 * 2.filter 接受两个参数，第一个是自定义名称，第二个是一个函数，并将值作为参数使用最后返回处理后的值 * 3.reverse 用于颠倒数组之前的顺序 * join 将数组按照指定分隔符进行分割，并返回一个字符串 * */ Vue.filter('customFilter', function(value) &#123; return value.split('').reverse().join('') &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'world', number: 148547, filterParam: 'small text!', dataArray: [ &#123;'name': 'Bruce', 'age': 1&#125;, &#123;'name': 'Chuck', 'age': 2, 'temp': 'Chuck123'&#125;, &#123;'name': 'Jack', 'age': 3&#125;, ] &#125; &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-filter</tag>
      </tags>
  </entry>
</search>
