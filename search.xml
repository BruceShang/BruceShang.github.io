<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue实现原理 - 如何实现双向绑定mvvm]]></title>
    <url>%2F2020%2F08%2F05%2FVue%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%20-%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Amvvm%2F</url>
    <content type="text"><![CDATA[本文能帮你做什么？1、了解vue的双向数据绑定原理以及核心代码模块2、缓解好奇心的同时了解如何实现双向绑定为了便于说明原理与实现，本文相关代码主要摘自vue源码, 并进行了简化改造，相对较简陋，并未考虑到数组的处理、数据的循环依赖等，也难免存在一些问题，欢迎大家指正。不过这些并不会影响大家的阅读和理解，相信看完本文后对大家在阅读vue源码的时候会更有帮助 相信大家对mvvm双向绑定应该都不陌生了，一言不合上代码，下面先看一个本文最终实现的效果吧，和vue一样的语法，如果还不了解双向绑定，猛戳Google 1234567891011121314151617181920212223&lt;div id="mvvm-app"&gt; &lt;input type="text" v-model="word"&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click="sayHi"&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src="./js/observer.js"&gt;&lt;/script&gt;&lt;script src="./js/watcher.js"&gt;&lt;/script&gt;&lt;script src="./js/compile.js"&gt;&lt;/script&gt;&lt;script src="./js/mvvm.js"&gt;&lt;/script&gt;&lt;script&gt;var vm = new MVVM(&#123; el: '#mvvm-app', data: &#123; word: 'Hello World!' &#125;, methods: &#123; sayHi: function() &#123; this.word = 'Hi, everybody!'; &#125; &#125; &#125;);&lt;/script&gt; 效果: 几种实现双向绑定的做法目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 实现数据绑定的做法有大致如下几种： 发布者-订阅者模式（backbone.js） 脏值检查（angular.js） 数据劫持（vue.js） 发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这里有篇文章讲的比较详细，有兴趣可点这里 这种方式现在毕竟太low了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式 这种方式现在毕竟太low了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式 脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 思路整理已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里 整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点： 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者 上述流程如图所示： 1、实现Observerok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it 我们知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样： 1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚： 12345678910111213141516171819// Observer.js// ...省略Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; &#125;&#125; 这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，完整代码。那么接下来就是实现Compile了 2、实现Compilecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示： 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将vue实例根节点的el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text="content"&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) &#123; var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) &#123; // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); &#125; else &#123; // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; &#125; &#125;); &#125;&#125;;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // ...省略 bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;&#125;;// 更新函数var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125; // ...省略&#125;; 这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了双大括号表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如: 1&lt;span v-text="content" other-attr 中v-text&gt;&lt;/span&gt; 便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知至此，一个简单的Compile就完成了，完整代码。接下来要看看Watcher这个订阅者的具体实现了 3、实现WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 如果有点乱，可以回顾下前面的思路整理 123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 ok, Watcher也已经实现了，完整代码。 基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。 最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了~ 4、实现MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 一个简单的MVVM构造器是这样子： 123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: ‘kindeng’}}); vm._data.name = ‘dmq’; 这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的： var vm = new MVVM({data: {name: ‘kindeng’}}); vm.name = ‘dmq’; 所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： 1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果，哈哈 至此，全部模块和功能已经完成了，如本文开头所承诺的两点。一个简单的MVVM模块已经实现，其思想和原理大部分来自经过简化改造的vue源码，猛戳这里可以看到本文的所有相关代码。 由于本文内容偏实践，所以代码量较多，且不宜列出大篇幅代码，所以建议想深入了解的童鞋可以再次结合本文源代码来进行阅读，这样会更加容易理解和掌握。 总结本文主要围绕“几种实现双向绑定的做法”、“实现Observer”、“实现Compile”、“实现Watcher”、“实现MVVM”这几个模块来阐述了双向绑定的原理和实现。并根据思路流程渐进梳理讲解了一些细节思路和比较关键的内容点，以及通过展示部分关键代码讲述了怎样一步步实现一个双向绑定MVVM。文中肯定会有一些不够严谨的思考和错误，欢迎大家指正，有兴趣欢迎一起探讨和改进~ 最后，感谢您的阅读！ 本文转载DMQ]]></content>
      <categories>
        <category>vue</category>
        <category>mvvm</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局]]></title>
    <url>%2F2020%2F08%2F03%2FFlex%20%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[为什么我要写这一篇关于 Flex 布局的教程？ 因为它十分简单灵活，区区简单几行代码就可以实现各种页面的的布局，以前我在学习页面布局的时候我深受其 float、display、position 这些属性的困扰。然而学习 Flex 布局，你只要学习几个 CSS 属性，就可以写出简洁优雅复杂的页面布局。 Flex 基本概念： 在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴，这个我们后面再说。 在容器中的每个单元块被称之为 flex item，每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。 这里需要强调，不能先入为主认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。 Flex 容器：首先，实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。 123.container &#123; display: flex | inline-flex; //可以有两种取值&#125; 分别生成一个块状或行内的 flex 容器盒子。简单说来，如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 有下面六种属性可以设置在容器上，它们分别是： flex-direction flex-wrap flex-flow justify-content align-items align-content 1. flex-direction: 决定主轴的方向(即项目的排列方向)123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 默认值：row，主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 2. flex-wrap: 决定容器内项目是否可换行默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 默认值：nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。 wrap：项目主轴总尺寸超出容器时换行，第一行在上方 wrap-reverse：换行，第一行在下方 3. flex-flow: flex-direction 和 flex-wrap 的简写形式123.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 默认值为: row nowrap，感觉没什么卵用，老老实实分开写就好了。这样就不用记住这个属性了。 4. justify-content：定义了项目在主轴的对齐方式。1234.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row 默认值: flex-start 左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。 space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 5. align-items: 定义了项目在交叉轴上的对齐方式1234.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 建立在主轴为水平方向时测试，即 flex-direction: row 默认值为 stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。 假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。flex-start：交叉轴的起点对齐 假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如上图显示。 flex-end：交叉轴的终点对齐center：交叉轴的中点对齐baseline: 项目的第一行文字的基线对齐 以文字的底部为主，仔细看图可以理解。 6. align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 这个这样理解： 当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。 当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。 建立在主轴为水平方向时测试，即 flex-direction: row, flex-wrap: wrap 默认值为 stretch，看下面的图就很好理解了 从图可以看出又三条轴线(因为容器宽度有限)，当值为 stretch 时会三条轴线平分容器的垂直方向上的空间。 值得注意的是，虽然在每条轴线上项目的默认值也为 stretch，但是由于我每个项目我都设置了高度，所以它并没有撑开整个容器。如果项目不设置高度的话就会变成下面这样： 这个我在前面也有提到(align-items)，这里重点还是理解三条轴线会平分垂直轴上的空间。 flex-start：轴线全部在交叉轴上的起点对齐 flex-end：轴线全部在交叉轴上的终点对齐 center：轴线全部在交叉轴上的中间对齐 space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。 space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。 到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item 上的属性。 Flex 项目属性：有六种属性可运用在 item 项目上： order flex-basis flex-grow flex-shrink flex align-self 1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0123.item &#123; order: &lt;integer&gt;;&#125; 在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。 2. flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间123 .item &#123; flex-basis: &lt;length&gt; | auto;&#125; 默认值：auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。 当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。 当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。 3. flex-grow: 定义项目的放大比例123.item &#123; flex-grow: &lt;number&gt;;&#125; 默认值为 0，即如果存在剩余空间，也不放大当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。 4. flex-shrink: 定义了项目的缩小比例123.item &#123; flex-shrink: &lt;number&gt;;&#125; 默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。 这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。同理可得： 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 5. flex: flex-grow, flex-shrink 和 flex-basis的简写123.item&#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。 有关快捷值：auto (1 1 auto) 和 none (0 0 auto) 关于 flex 取值，还有许多特殊的情况，可以按以下来进行划分： 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的： 123456.item &#123;flex: 1;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; 当 flex 取值为 0 时，对应的三个值分别为 0 1 0% 123456.item &#123;flex: 0;&#125;.item &#123; flex-grow: 0; flex-shrink: 1; flex-basis: 0%;&#125; 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字） 12345678910111213.item-1 &#123;flex: 0%;&#125;.item-1 &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125;.item-2 &#123;flex: 24px;&#125;.item-2 &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 24px;&#125; 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的： 123456.item &#123;flex: 2 3;&#125;.item &#123; flex-grow: 2; flex-shrink: 3; flex-basis: 0%;&#125; 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的： 123456.item &#123;flex: 11 32px;&#125;.item &#123; flex-grow: 11; flex-shrink: 1; flex-basis: 32px;&#125; 建议优先使用这个属性，而不是单独写三个分离的属性。 grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。 grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。 另外感谢@王嘉成 在评论区的补充说明容器的 flex-wrap 与子项的 flex-shrink、flex-grow 之间的关系： 当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大） 当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据 当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大） 当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条 总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用 align-self: 允许单个项目有与其他项目不一样的对齐方式 单个项目覆盖 align-items 定义的属性 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。 容器 align-items 设置为 flex-start，而第三 本文转载前端客栈]]></content>
      <categories>
        <category>css</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决vue fastclick $refs.file.click() 需要点击多次才生效]]></title>
    <url>%2F2020%2F04%2F15%2F%E8%A7%A3%E5%86%B3vue%20fastclick%20%24refs.file.click()%20%E9%9C%80%E8%A6%81%E7%82%B9%E5%87%BB%E5%A4%9A%E6%AC%A1%E6%89%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[项目背景1.移动端h5项目2.项目中使用了fastclick3.h5页面需要用户上传身份证图片 实现原理fastclick是通过在touchstart里记录触摸点信息，在touchend里判断此次触摸是否是个有效的click点击，如果是，则在touchend里阻止默认事件以防止产生原生click事件（因为会有 300ms 的延迟），并立即生成并触发自定义的click事件（没有延迟） 哪些情况不需要 fastclick在代码里引入fastclick后，初始化fastclick时会做一些检测，当检测出如下情况时，将不会使用fastclick： 设备不支持touch事件 Chrome 浏览器 桌面版 Chrome 浏览器 Android Chrome，以下两种情况都不需要fastclick eta里有user-scalable=no Chrome 版本 &gt;= 32，且meta里有width=device-width IE 浏览器 IE 11+，传入fastclick.attach的元素包含 CSS 样式，touch-action: manipulation; IE 10，传入fastclick.attach的元素包含 CSS 样式，-ms-touch-action: manipulation; BlackBerry 浏览器 版本 &gt;= 10.3，且meta里有user-scalable=no或width=device-width Firefox 浏览器 版本 &gt;= 27，且meta里有user-scalable=no或width=device-width 存在的问题手动触发 element.click() 无效 div1，点击此处，将在 div1 的 click 回调里触发 div2.click() div2，div2 的 click 回调里将 tootle 背景色 问题描述可能存在这样的需求，点击元素div1，在div1元素的click回调函数里再以代码方式触发另一元素div2的click事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class="fastclick-bug"&gt; &lt;div class="div1" @click="clickDiv1" &gt; div1，点击此处，将在 div1 的 click 回调里触发 div2.click() &lt;/div&gt; &lt;div ref="div2" class="div2" :class="&#123;'div2-bg': div2Bg&#125;" @click="clickDiv2" &gt; div2，div2 的 click 回调里将 tootle 背景色 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'VueTapFastclickBug', data() &#123; return &#123; div2Bg: false &#125;; &#125;, mounted() &#123; // 在浏览器端再执行 fastclick import('fastclick').then(Fastclick =&gt; &#123; Fastclick.attach(document.body); &#125;); &#125;, methods: &#123; clickDiv1() &#123; this.$refs.div2.click(); &#125;, clickDiv2() &#123; this.div2Bg = !this.div2Bg; &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang="less" scoped&gt;.div1,.div2 &#123; margin: 20px; background: gray;&#125;.div2-bg &#123; background: red;&#125;&lt;/style&gt; 若是使用了fastclick，但Android上可以按预期运行（实际上是这个Android手机的 Chrome 版本 &gt;= 32，且meta里有width=device-width，没使用到fastclick）。 在 iOS 上，this.$refs.div2.click();这一行代码不会生效，但将这一行代码写两遍，即手动触发div2.click()两次，代码就会按预期运行。 问题原因当点击屏幕时，fastclick在touchstart里会设置fastclick实例的targetElement属性为当前事件的目标元素。 1234567891011121314FastClick.prototype.onTouchStart = function(event) &#123; var targetElement, touch, selection; if (event.targetTouches.length &gt; 1) &#123; return true; &#125; // 事件目标元素 targetElement = this.getTargetElementFromEventTarget(event.target); // ... // 设置 fastclick 实例的 targetElement 属性为当前事件的目标元素 this.targetElement = targetElement; // ... return true;&#125;; 但是通过this.$refs.div2.click();是在 js 里以编程方式触发click事件，不会产生touchstart事件，因此无法重新设置this.targetElement，而且在点击了div1之后，this.targetElement也没有重置为null，其值仍为div1。 123456789101112131415161718192021222324function FastClick(layer, options) &#123; // ... var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel']; var context = this; for (var i = 0, l = methods.length; i &lt; l; i++) &#123; context[methods[i]] = bind(context[methods[i]], context); &#125; // Set up event handlers as required if (deviceIsAndroid) &#123; layer.addEventListener('mouseover', this.onMouse, true); layer.addEventListener('mousedown', this.onMouse, true); layer.addEventListener('mouseup', this.onMouse, true); &#125; // 注意，click 事件是在捕获阶段监听处理的 layer.addEventListener('click', this.onClick, true); layer.addEventListener('touchstart', this.onTouchStart, false); layer.addEventListener('touchmove', this.onTouchMove, false); layer.addEventListener('touchend', this.onTouchEnd, false); layer.addEventListener('touchcancel', this.onTouchCancel, false); // ...&#125; 第一次div2.click()时，会在事件捕获阶段被layer（一般是document.body）上的监听函数处理，即this.onClick。在onClick里会调用onMouse，onMouse里通过needsClick判断出this.targetElement即div1不需要原生click事件，因此会阻止该事件的默认行为以及阻止事件冒泡/捕获，并将this.targetElement置为null。因此第一次的div2.click()在事件捕获阶段被layer的事件处理函数给阻止了捕获阶段的进步传播，最终事件未传播到div2上，div2的click事件也未执行。 因为在第一次div1.click()时已经将this.targetElement重置为null了，第二次div2.click()时在onMouse里判断出this.targetElement为null后直接返回true，而没有机会执行之后的needsClick以及阻止事件捕获的逻辑，事件会进一步传播到div2上，因此第二次的div2.click()生效了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384FastClick.prototype.needsClick = function(target) &#123; switch (target.nodeName.toLowerCase()) &#123; // Don't send a synthetic click to disabled inputs (issue #62) case 'button': case 'select': case 'textarea': if (target.disabled) &#123; return true; &#125; break; case 'input': // File inputs need real clicks on iOS 6 due to a browser bug (issue #68) if ((deviceIsIOS &amp;&amp; target.type === 'file') || target.disabled) &#123; return true; &#125; break; case 'label': case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames case 'video': return true; &#125; return (/\bneedsclick\b/).test(target.className);&#125;;FastClick.prototype.onMouse = function(event) &#123; // If a target element was never set (because a touch event was never fired) allow the event if (!this.targetElement) &#123; return true; &#125; if (event.forwardedTouchEvent) &#123; return true; &#125; // Programmatically generated events targeting a specific element should be permitted if (!event.cancelable) &#123; return true; &#125; // Derive and check the target element to see whether the mouse event needs to be permitted; // unless explicitly enabled, prevent non-touch click events from triggering actions, // to prevent ghost/doubleclicks. if (!this.needsClick(this.targetElement) || this.cancelNextClick) &#123; // Prevent any user-added listeners declared on FastClick element from being fired. // 阻止事件冒泡并且阻止相同事件的其他侦听器被调用 if (event.stopImmediatePropagation) &#123; event.stopImmediatePropagation(); &#125; else &#123; // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2) event.propagationStopped = true; &#125; // Cancel the event event.stopPropagation(); event.preventDefault(); return false; &#125; // If the mouse event is permitted, return true for the action to go through. return true;&#125;;FastClick.prototype.onClick = function(event) &#123; // ... permitted = this.onMouse(event); // ... // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through. // 若不允许此次 click 事件，则重置 this.targetElement if (!permitted) &#123; this.targetElement = null; &#125; // If clicks are permitted, return true for the action to go through. return permitted;&#125;; PS：DOM Level 2 里事件处理函数handler里的return false即不会阻止默认事件，也不会阻止冒泡。 解决方案方案一：添加 needsclick 类（不推荐）12345&lt;div class="div1 needsclick" @click="clickDiv1"&gt; div1，点击此处，将在 div1 的 click 回调里触发 div2.click() &lt;/div&gt; 在div1元素上添加needsclick类，这样点击div1时不会触发fastclick自定义的click事件，而是原生click事件（会存在 300 ms 延迟的问题）。 且仅需要执行一次div2.click()，执行时needsclick函数根据div1上的needsclick判断出this.targetElement即div1需要原生click事件，就不会阻止事件的进一步传播，最终div2上的click事件回调顺利执行。 方案二：使用 element.dispatchEvent(event) 触发事件（推荐）1234clickDiv1() &#123; const event = new MouseEvent('click'); this.$refs.div2.dispatchEvent(event);&#125;, 通过new MouseEvent(‘click’)创建的事件，默认的event.cancelable和event.cancelBubble都为false，因此走到onMouse里会直接返回true，没有机会执行之后的needsClick以及阻止事件捕获的逻辑，会让事件进一步传播到div2上，进而触发了div2的click事件。 注意：div2上的事件，不能是采用事件代理注册在其祖先元素上的click事件.]]></content>
      <categories>
        <category>vue</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>fastclick</tag>
        <tag>file.click</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域资源共享(CORS) 的一些注意事项]]></title>
    <url>%2F2020%2F04%2F02%2F%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[公司要推广产品，找了一个平台投放广告。正式投放之前平台商要求对接他们的API埋点接口，在对接的过程中碰到的一些问题做个记录。 要解决跨域问题，首先先明白浏览器为什么会产生跨域。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 第一次请求尝试碰到下面报错信息 这张图是对接的后端开发截取他的配置信息 原因是：我们前端设置了 axios.defaults.withCredentials = true ; 而后端在请求响应头上加了 Access-Control-Allow-Origin: * 。 为什么这样设置就出问题了呢？ 我们先来了解一下 withCredentials 的作用 withCredentials 属性是一个Boolean类型，它指示了是否该使用类似cookies,authorization headers(头部授权)或者TLS客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site Access-Control）请求。在同一个站点下使用withCredentials属性是无效的。 说白了就是：当前请求为跨域类型时是否在请求中协带cookie。 到了这里基本上就明白了，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 stackoverflow: CORS: Cannot use wildcard in Access-Control-Allow-Origin when credentials flag is true 我以外大功告成，试了一把，又红了… 原因是：我们在请求头部加了一个 Authorization字段，而后端需要再响应头部Access-Control-Request-Headers添加一下Authorization字段。 那这个Access-Control-Request-Headers是干嘛用的呢？ 响应首部 Access-Control-Allow-Headers 用于 preflight request （预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers 字段中出现的首部信息。 以上是一个简单的跨域资源共享 CORS处理方法常碰到的问题，cors 还有一个 “非简单请求”真实请求之前需要先从客户端向服务器端发一个预检请求，感兴趣的可以自行Google。 改完之后再试一下，终于大功告成。泪流满面…全程都是这边在推动向前进，外部API对接的后端有点不太给力哦。😯]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间通信几种方法]]></title>
    <url>%2F2020%2F03%2F31%2Fvue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[跨组件【订阅/发布】模式描述：vue2.0支持 12345678var bus = new Vue();//把值发送指定频道bus.$emit('fcName',1)//接收指定频道的值bus.$on('fcName',function(id)&#123; console.log(id);&#125;); 通过prop向子组件通信12345&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button type="button" @click="clickRef"&gt;调用子组件&lt;/button&gt; &lt;child :message="total"&gt;&lt;/child&gt;&lt;/div&gt; message前加”:” total是动态数据，未加total是静态数据 123456789101112131415161718Vue.component('child',&#123; template:'&lt;div&gt;全局组件：&#123;&#123; message &#125;&#125;&lt;/div&gt;', props: &#123; //允许值类型，用数组表示 message: [String, Number] &#125;&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; total: 1 &#125;, methods: &#123; clickRef: function()&#123; this.total++; &#125; &#125;&#125;); 子组件调用父组件1234&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;simple @increment = "parentFn"&gt;&lt;/simple&gt;&lt;/div&gt; 12345678910111213141516171819202122//定义全局组件 Vue.component('simple',&#123; template: '&lt;button @click="fns"&gt;子组件click&lt;/button&gt;', methods: &#123; fns: function()&#123; this.$emit('increment'); &#125; &#125; &#125;); var vm = new Vue(&#123; el: '#app', data: &#123; total: 1 &#125;, methods: &#123; //在子组件调用emit() 来触发。 parentFn: function()&#123; this.total++; &#125; &#125; &#125;); 备注：该方式主要通过子组件emit()方法来实现。 父组件调子组件方法和数据 12345&lt;div id="app"&gt; &lt;p&gt;总次数：&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button @click="parentClick"&gt;调子组件&lt;/button&gt; &lt;simple ref="children"&gt;&lt;/simple&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728//定义全局组件 Vue.component('simple',&#123; template: '&lt;button @click="fns"&gt;子组件次数(&#123;&#123; num &#125;&#125;)&lt;/button&gt;', data: function()&#123; return &#123; num: 0&#125; &#125;, methods: &#123; fns: function()&#123; this.num++; &#125; &#125; &#125;); //实例化Vue对象 var vm = new Vue(&#123; el: '#app', data: &#123; total: 1 &#125;, methods: &#123; //在子组件调用emit() 来触发。 parentClick: function()&#123; this.total++; var child = this.$refs.children; child.fns(); &#125; &#125; &#125;); 使用v-model进行通信1234567891011121314151617181920212223242526272829303132333435Vue.component('my-component', &#123; template: `&lt;div&gt;&#123;&#123;currentVal&#125;&#125;这是：，&lt;button @click="foo"&gt;传递&lt;/button&gt;&lt;/div&gt;`, props: ['value'], // 必须 data() &#123; return &#123; currentVal: this.value // 必须 &#125; &#125;, // 必须 watch: &#123; currentVal(val) &#123; this.$emit('input', val) &#125;, value(val)&#123; this.currentVal = val &#125; &#125;, methods: &#123; foo() &#123; this.currentVal++ &#125;, &#125;,&#125;)var appMain = new Vue(&#123; el: '#app', data: &#123; num: 3, &#125;, methods: &#123; clickMe() &#123; this.num ++ &#125; &#125;&#125;) html 12345&lt;div id="app"&gt; &lt;p&gt;总次数：&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button @click="parentClick"&gt;调子组件&lt;/button&gt; &lt;simple ref="children"&gt;&lt;/simple&gt;&lt;/div&gt; 转载: Y. Jer 的虚拟笔记]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort()对数组元素进行排序]]></title>
    <url>%2F2020%2F03%2F27%2Fsort-%E5%AF%B9%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.语法1arr.sort([compareFunction]) 参数 compareFunction 可选 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 firstEl 第一个用于比较的元素。 secondEl 第二个用于比较的元素。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前 2.比较数字类型的值，可以通过a-b来实现升序排列12345let numbers = [9, 8, 5, 2, 1, 0]numbers.sort((a, b) =&gt; &#123; return a - b;&#125;)console.log(numbers) 3.根据数组里的对象属性进行排序123456789101112131415161718192021222324252627282930313233343536var items = [ &#123; name: 'Edward', value: 21, txtName: '震耳欲聋' &#125;, &#123; name: 'Sharpe', value: 37, txtName: '锦上添花' &#125;, &#123; name: 'And', value: 45, txtName: '八仙过海' &#125;, &#123; name: 'The', value: -12, txtName: '我行我素' &#125;, &#123; name: 'Magnetic', value: 33, txtName: '大吉大利' &#125;, &#123; name: 'Zeros', value: 37, txtName: '五福临门' &#125;];// 根据value值（数字类型）items.sort(function (a, b) &#123; return (a.value - b.value)&#125;);// 根据name字段 - 字母 items.sort(function(a, b) &#123; var nameA = a.name.toUpperCase(); var nameB = b.name.toUpperCase(); if (nameA &lt; nameB) &#123; return -1; &#125; if (nameA &gt; nameB) &#123; return 1; &#125; return 0;&#125;);// 根据数组对象里的 汉字 进行排序/* * 当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）一些* 非英语语言的字符串需要使用 String.localeCompare。这个函数可以将函数排序到正* 确的顺序。*/items.sort(function(a, b) &#123; return a.txtName.localeCompare(b.txtName);&#125;) localeCompare详解 4.使用映射改善排序 compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。 1234567891011121314151617// 需要被排序的数组var list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];// 对需要排序的数字和位置的临时存储var mapped = list.map(function(el, i) &#123; return &#123; index: i, value: el.toLowerCase() &#125;;&#125;)// 按照多个值排序数组mapped.sort(function(a, b) &#123; return +(a.value &gt; b.value) || +(a.value === b.value) - 1;&#125;);// 根据索引得到排序的结果var result = mapped.map(function(el)&#123; return list[el.index];&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>sort()</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%BE%AE%E4%BF%A1%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%BB%91%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%BC%B9%E6%A1%86%E9%87%8C%E7%9A%84%E6%8C%89%E9%92%AE%E5%93%8D%E5%BA%94%E5%8C%BA%E5%9F%9F%E9%94%99%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>微信ios 6.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fatal: unable to access ' ':Could not resolve host: github.com解决方案]]></title>
    <url>%2F2019%2F06%2F05%2Ffatal%3A%20unable%20to%20access%20'%20'%3ACould%20not%20resolve%20host%3A%20github.com%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一、在终端输入：1sudo vim /etc/resolv.conf 在最后一行增加nameserver 8.8.8.8或者nameserver 114.114.114.114即可。 114.114.114.114和8.8.8.8，这两个IP地址都属于公共域名解析服务DNS其中的一部分 二、114.114.114.114114.114.114.114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS。 三、8.8.8.8 8.8.8.8是GOOGLE公司提供的DNS，该地址是全球通用的，相对来说，更适合国外以及访问国外网站的用户使用。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BD%BF%E7%94%A8Generic%20Webhook%20Trigger%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Jenkins%2BWebHooks%EF%BC%88%E7%A0%81%E4%BA%91%EF%BC%89%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[一、下载插件安装Generic Webhook Trigger插件在“系统设置–插件管理–可选插件”界面搜索：Generic Webhook Trigger，可以看到，点击安装，然后重启。 二、构建触发 三、配置用户和Security 四、配置码云WebHooks 找到WebHooks配置界面，在POST地址框中输入如下格式内容： 1http://&lt;User ID&gt;:&lt;API Token&gt;@&lt;Jenkins IP地址&gt;:端口/generic-webhook-trigger/invoke 12// 例：http://admin:1156a09fc1c858c800a9e88a2c276@107.12.84.144:8082/generic-webhook-trigger/invoke User ID：既是“三（1）”中的User ID，我的是admin API Token：既是“三（1）”中的API Token Jenkins IP地址：就是你的Jenkins的服务器IP地址，这个必须是公网IP地址。 端口：就是Jenkins服务器的端口 测试接口成功 自动发布成功 本文参考文章Jenkins系列1.使用Jenkins搭建前端构建环境2.Jenkins安装插件动态获取git分支3.使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins安装插件动态获取git分支]]></title>
    <url>%2F2019%2F05%2F09%2FJenkins%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96git%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[一、下载插件在管理中选插件，搜索Git Parameter点击安装。 二、参数化配置1、选择项目-设置-General-选择参数化构建过程 &gt; 添加Git Parameter 配置分支信息 2、源码管理配 三、完成 本文转载链接地址Jenkins系列1.使用Jenkins搭建前端构建环境2.Jenkins安装插件动态获取git分支3.使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex 配置安卓开发环境]]></title>
    <url>%2F2019%2F01%2F31%2Fweex-%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1.安装依赖安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： 1brew install node 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 1npm install -g weex-toolkit 2.初始化weex项目12345678// 1.生成项目weex create awesome-app// 2.进入项目cd awesome-app// 3.安装依赖npm install// 4.启动项目npm start 3.调试查看网络请求信息weex-toolkit 还提供了强大的调试功能，只需要执行： 1weex debug 调试详情步骤 4.集成weex到应用 1.安装安卓运行环境JDK 2.安装Android SDK并配置环境变量 这里我是下载了Android Studio编辑器，打开软件的时候在内部会自动安装，只需要耐心等一下。 5.打包安装1weex run android 6.打包$ANDROID_HOME not found !问题这是没有将sdk配置到环境变量中 123456// 进入配置文件vi ~/.zshrc// 将下面代码放入文件中export ANDROID_HOME=/Users/shangzhen/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 这是sdk的安装位置，在这里可以看到。最后千万别忘了最后一步1source ~/.zshrc 配置好之后一定要重新开一个终端执行命令 7.Build failed with an exception 问题解决123456789// 报错信息FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project ':app'.&gt; You have not accepted the license agreements of the following SDK components: [Android SDK Platform 23, Android SDK Build-Tools 23.0.2]. Before building your project, you need to accept the license agreements and complete the installation of the missing components using the Android Studio SDK Manager. Alternatively, to learn how to transfer the license agreements from one workstation to another, go to http://d.android.com/r/studio-ui/export-licenses.html 执行命令解决1$ANDROID_HOME/tools/bin/sdkmanager --licenses 看到这个页面就代表许可证安装完成了 8.执行 weex run android用一个安卓手机，连接到自己的电脑，手机上开启开发调试模式。编译通过，打包安装到真机上的APP效果图：]]></content>
      <categories>
        <category>weex</category>
        <category>native</category>
      </categories>
      <tags>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins搭建前端构建环境]]></title>
    <url>%2F2019%2F01%2F04%2F%E4%BD%BF%E7%94%A8Jenkins%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前期准备1.CentOS服务器2.Jenkins3.github账号4.Nginx 这里Nginx的配置就不多说了，有兴趣的话可以参考前面的文章同台服务器上nginx配置多个服务站点共用80端口 服务器环境配置 先将Jenkins网站中的Jenkins存储库添加到包管理器中 12wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.reporpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key 下载安装java和git依赖包 12yum install javayum install git 登录服务器生成ssh key12345// 设置提交用户名和邮箱git config --global user.name "xxx"git config --global user.email "xxxx@qq.com"// 开始生成keyssh-keygen -t rsa -C "yourEmail@xxx.com" 一路回车后就成功生成了 测试一下ssh是否能成功使用1ssh github.com 出现下面情况代表可以正常使用 最后：拷贝服务器中的公钥添加到github中 什么是jenkins呢? Jenkins是一个独立的开源自动化服务器，可用于自动执行与构建，测试，交付或部署软件相关的各种任务。Jenkins可以通过本机系统软件包，Docker安装，甚至可以由安装了Java Runtime Environment（JRE）的任何机器独立运行。 安装Jenkins1yum install jenkins Jenkins配置12// 进入Jenkins配置文件地址：vim /etc/sysconfig/jenkins Jenkins配置文件中的几个重要的参数1234JENKINS_HOME="/var/lib/jenkins" // Jenkins存储配置和工作的目录JENKINS_USER="root" // 将字段值修改root权限// 注意：Jenkins默认的端口号是8080，需要修改的可以在这里修改JENKINS_PORT="8082" // Jenkins端口号 启动Jenkins1service jenkins restart 启动成功后我们在浏览器中输入ip地址和端口号，进入解锁页面 输入密码后，继续进入下一步，进入新手页面。 选择第一个推荐插件安装 安装中… 创建管理员用户 实例配置 创建任务 构建一个自由风格的软件项目 安装两个插件系统管理&gt;插件管理&gt;可选插件中搜索并安装，安装成功后需要重启 1234// 部署项目时需要执行node安装依赖1.NodeJS Plugin // 实现jenkins将服务器构建打包好的war包自动发布到应用服务器，并部署运行2.Publish Over SSH 进入 系统管理 =&gt; 系统设置页面配置Jenkins LocationJenkins服务器地址 Publish over SSH配置Publish over SSH 这里有一点容易出错：Jenkins服务器（A）应用服务器（B） 应用服务器（B）上创建~/.ssh文件夹和~/.ssh/authorized_keys文件，并将jenkins服务器(A)的公钥id_rsa.pub中的内容复制到authorized_keys文件 应用服务器上重启ssh服务，service sshd restart 现在jenkins服务器可免密码直接登陆应用服务器 开始任务配置 源码管理的凭据和 api的凭据不是一样的，apiv5的凭据是插件调用码云接口使用的，而源码管理的凭据是jenkins git插件要求的，这&gt; 个凭据格式是用户名密码，如果用的是http的协议需要在凭据管理中再配置一个码云用户名密码的凭据，这样才能选上，如果是ssh 的话&gt; 需要jenkins的机器的ssh key 加入到码云账号中才行 凭据 》系统 》添加域 构建环境系统管理 》全局工具配置 》NodeJS；如果不添加nodejs在下面 NodeJS Installation 中将不会出来内容 构建 选择Send build artifacts over SSH配置 构建后操作 测试一下部署发布 完美部署暂时先写这么多吧，有空会继续更新…Jenkins系列1.使用Jenkins搭建前端构建环境2.Jenkins安装插件动态获取git分支3.使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Yeoman制作自己的脚手架]]></title>
    <url>%2F2019%2F01%2F02%2F%E4%BD%BF%E7%94%A8Yeoman%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[基于generator-vuecli-3-mobile为例 导读面对复杂的 Web 应用的开发，良好的流程和工具支持是必不可少的，可以让日常的开发工作更加顺畅。Yeoman 作为一个流行的工具集，在整合了 Yo、Grunt 和 Bower 等工具的基础上，定义了一个更加完备和清晰的工作流程。通过把一些最佳实践引入到 Web 应用中，有助于创建高质量和可维护的应用。 环境需要安装Nodejs 全局安装yo 1npm install -g yo 安装generator-generator,生成自己需要的generator的基础框架 1npm install -g generator-generator 运行命令开始生成基础代码1yo generator 设置之后 检查一下生成的目录结构 12345678910111213141516.├── generators/│ └── app/│ ├── index.js // 设置项目模板文件│ └── templates/ // 存放模板文件│ └── dummyfile.txt├── .editorconfig├── .gitattributes├── .gitignore├── .eslintrc├── .travis.yml├── .yo-rc.json // 存储项目配置├── package.json├── gulpfile.js├── README.md├── LICENSE 将模板文件放入到 generators/app/templates文件夹后，我们开始编辑 index.js 文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273'use strict';const Generator = require('yeoman-generator');const chalk = require('chalk');const yosay = require('yosay');const glob = require('globby');const path = require('path');module.exports = class extends Generator &#123; prompting() &#123; this.log( yosay(`Welcome to the phenomenal $&#123;chalk.red('generator-test-generator')&#125; generator!`) ); const prompts = [ &#123; type: 'confirm', name: 'someAnswer', message: 'Would you like to enable this option?', default: true &#125;, &#123; type: 'input', name: 'project-version', message: '项目版本号', default: '0.0.1' &#125; ... // 可以根据自己的需要自行配置 ]; return this.prompt(prompts).then(props =&gt; &#123; this.props = props; &#125;); &#125; /** * 写入文件 */ writing() &#123; this._writeRootFiles(); this._writeFolders(); &#125; // 项目中的文件夹内容 _writeFolders() &#123; ['public', 'src'].forEach(floder =&gt; &#123; this.fs.copy( this.templatePath(floder), this.destinationPath(floder) ) &#125;); &#125; // 根目录下的文件 _writeRootFiles() &#123; glob .sync([this.templatePath('*'), this.templatePath('package.json')]) .forEach(file =&gt; &#123; this.fs.copy( this.templatePath(file), this.destinationPath(path.basename(file).replace(/^_/, '')) ) &#125;); this.fs.copyTpl( this.templatePath('package.json'), this.destinationPath('package.json'), this.props ); &#125; /** * 安装方法 */ install() &#123; // 安装 package 安装. this.installDependencies(&#123; bower: false &#125;); &#125;&#125;; 提交到git仓库12345git init // 初始化git add . // 添加所以要提交的文件git commit -m 'first commit' // 添加提交描述git remote add origin https://github.com/BruceShang/generator-vuecli-3-mobile.git // 将文件添加到新仓库地址git push -u origin master // 推送到master分支 发布到npm 登录or注册账号 12345npm publish --access=public// 发布成功后会返回版本号+ generator-vuecli-3-mobile@0.0.4 如何使用1yo vuecli-3-mobile 升级脚手架实际开发中我们难免会多次修改项目，如何升级脚手架呢？ 1.修改项目中package.json里的version版本号 2.重新发布 1npm publish 3.重新安装全局脚手架 1234sudo npm i vuecli-3-mobile@1.0.1 -g// 或者 先卸载之前的安装，再重新安装sudo npm uninstall vuecli-3-mobile -gsudo npm install vuecli-3-mobile -g]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Yeoman</tag>
        <tag>脚手架</tag>
        <tag>自己的脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同台服务器上nginx配置多个服务站点共用80端口]]></title>
    <url>%2F2018%2F12%2F26%2F%E5%90%8C%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8Anginx%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9%E5%85%B1%E7%94%A880%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[登录服务器修改主配置文件1vim /etc/nginx/nginx.conf 12345678910111213141516171819http &#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; // 自定义的所有Nginx配置都自动加载到主配置文件中 include /etc/nginx/conf.d/*.conf;&#125; 在 /etc/nginx/conf.d文件中创建一个自己的配置文件 demp.conf 文件 1234567891011121314server &#123; listen 8080; // 端口号 server_name test.com test2.com localhost; // 设置域名 可以写多个，与名之间用空格隔开 location / &#123; root /root/xxx; // 资源文件地址 index index.html index.htm; // 指定入口文件 &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 重启Nginx,发现报错了。1Job for nginx.service failed because the control process exited with error code. See "systemctl status nginx.service" and "journalctl -xe" for details.、 在网上查了一下资料，找到了问题的解决方案： 1.先查看一下日志systemctl status nginx.service 1234567891011121314151617nginx.service - The nginx HTTP and reverse proxy server Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled) Active: active (running) since 三 2018-12-26 19:47:13 CST; 1h 25min ago Process: 18294 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS) Process: 18290 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS) Process: 18289 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS) Main PID: 18296 (nginx) CGroup: /system.slice/nginx.service ├─18296 nginx: master process /usr/sbin/nginx └─18297 nginx: worker process12月 26 19:47:13 instance-8c351jii systemd[1]: Starting The nginx HTTP and reverse proxy.....12月 26 19:47:13 instance-8c351jii nginx[18290]: nginx: the configuration file /etc/ngin...ok12月 26 19:47:13 instance-8c351jii nginx[18290]: nginx: configuration file /etc/nginx/ng...ul12月 26 19:47:13 instance-8c351jii systemd[1]: Failed to read PID from file /run/nginx.p...nt12月 26 19:47:13 instance-8c351jii systemd[1]: Started The nginx HTTP and reverse proxy ...r.Hint: Some lines were ellipsized, use -l to show in full. 2.killall nginx 3.service nginx restart vue项目部署后，发现路由history模式刷新以后出现404，这是因为我们的是单页客户端应用第一种解决方案123456789location /&#123; root /root/xxx; index index.html index.htm; // 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 if (!-e $request_filename) &#123; rewrite ^/(.*) /index.html last; break; &#125;&#125; 第二种解决方案12345location / &#123; root /root/xxx; index index.html index.htm; try_files $uri $uri/ /index.html; // 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。&#125; 官网给出的解决方案 大功告成，问题都解决了。]]></content>
      <categories>
        <category>服务</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 3.x使用配置]]></title>
    <url>%2F2018%2F12%2F24%2Fvue-cli-3-x%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装 Node 版本要求Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。 123npm install -g @vue/cli# ORyarn global add @vue/cli 检查版本是否正确（3.x）1vue --version 如果需要使用旧版本的 vue init 功能，可以全局安装一个桥接工具：1npm install -g @vue/cli-init 创建项目1vue create projectName 这里我选择自定义项目 选择自己项目中需要安装的包，选择后点击‘空格’选中，回车下一步： 输入‘Y’路由使用history模式 选择一个自己喜欢的css预处理器，这里我选择了stylus 选择eslint 标准 保存lint 选择将Babel,postCSS, ESLint配置在专用配置文件中，还是在pakage.json中。 启动项目1npm run serve 启动后可能碰到的问题 问题： 解决方案 如何在webpack中添加的配置呢？ 首先在项目最外层创建一个vue.config.js的文件，configureWebpack选项提供一个对象,该对象将会被 webpack-merge 合并入最终的 webpack 配置。 123456789 module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; 我们习惯了再vue-cli 2.x中配置文件别名，那么在vue-cli 3.x中如何配置？ 还是在vue.config.js 文件中配置chainWebpack对象 12345678910111213const path = require('path')function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; chainWebpack: config =&gt; &#123; config.resolve.alias .set('@', resolve('src')) .set('assets', resolve('src/assets')) .set('views', resolve('src/views')) &#125;&#125; 更多关于vue.config.js文件的配置 总结vue-cli 2.x的时候配置文件都暴露在项目中，对于多人协同开发的项目，开发人员有时候会自主根据自己的意愿进行修改，对于刚入手vue的人来说多人开发很容易把项目改乱，对于管理员维护不方便。以前使用2.x的时候，我都是把项目中的依赖、配置文件单独提出来，抽出一个单独的SDK打成npm包，发到线上。现在vue-cli 3.x已经把这些配置文件都抽成了npm包，同时只预留一些配置入口，着实方便不少，在项目中只需简单的配置就完成了一个项目搭建。]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>vue-cli 3</tag>
        <tag>vue脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5 唤醒App]]></title>
    <url>%2F2018%2F09%2F30%2Fh5-%E5%94%A4%E9%86%92App%2F</url>
    <content type="text"><![CDATA[这里我们来看看scheme拼接协议的格式：&lt; a href=”[scheme]://[host]/[path]?[query]”&gt;启动应用程序&lt; /a&gt; 各个项目含义如下所示： scheme：判别启动的App。 ※详细后述 host：适当记述 path：传值时必须的key ※没有也可以 query：获取值的Key和Value ※没有也可以]]></content>
      <categories>
        <category>h5</category>
        <category>App</category>
      </categories>
      <tags>
        <tag>h5</tag>
        <tag>唤醒App</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli build打包后CSS浏览器兼容前缀自动去除的问题]]></title>
    <url>%2F2018%2F09%2F25%2Fvue-cli-build%E6%89%93%E5%8C%85%E5%90%8ECSS%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E5%89%8D%E7%BC%80%E8%87%AA%E5%8A%A8%E5%8E%BB%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天做练手项目部署的时候碰到了个奇怪问题，开发环境里显示得好好的CSS prefixer样式，到production环境就消失了。我开发环境用的是 scss ，刚开始我还以为是 scss 处理器的问题，后来研究了下 build 脚本，发现人家把CSS统一用一个插件给压缩了，然后追查之下发现这个插件用了 postCSS 的 autoprefixer 插件。这下问题就清楚了，因为 autoprefixer 插件会针对支持的浏览器进行CSS 前缀的删除和追加。 比如： 1234a &#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 编译成： 123a &#123; border-radius: 5px;&#125; autoprefixer 使用了 browserslist 作为依赖。在项目目录中运行: 1npx browserslist 可以查看当前项目支持的浏览器列表，这时候只要修改当前项目支持的浏览器就可以了。vue-cli生成的项目默认支持部分移动端浏览器和最新版本的PC端浏览器。 在 package.json 中修改 browserslist 12345678"browserslist": [ "&gt; 1%", "last 2 versions", "last 10 Chrome versions", "last 5 Firefox versions", "Safari &gt;= 6", "ie &gt; 8"] 如果是h5移动端项目中需要兼容iPhone 5 （ios8）的需要如下配置： 12345678910"browserslist": [ "&gt; 1%", "last 2 versions", "last 10 Chrome versions", "last 5 Firefox versions", "Safari &gt;= 6", "ie &gt; 8", "ios &gt;= 7", "android &gt;= 4.3"], 之后再运行 npm run build 这时生成的代码就有 css prefix 了。 博客原文：http://www.zhuyuwei.cn/2018/vue-cli-css-prefixer.html]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
        <tag>h5中ios8兼容问题</tag>
        <tag>vue-cli打包后css前缀自动去除问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue项目中使用百度分享]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[环境：在vue项目中使用html部分123456789&lt;div class="share__wrap"&gt; &lt;div class="share__content"&gt; &lt;div class="bdsharebuttonbox col-xs-5 share__wrapper"&gt; &lt;a class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"&gt;分享到QQ空间&lt;/a&gt; &lt;a class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"&gt;分享到新浪微博&lt;/a&gt; &lt;a class="bds_renren" data-cmd="renren" title="分享到人人网"&gt;分享到人人网&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; js部分1234567891011121314151617181920212223242526272829303132/** * 顶部分享 * @param &#123;string&#125; img - 图片地址 * @param &#123;string&#125; text - 文本提示 * @param &#123;string&#125; desc - 描述 */const share = (img, text, desc) =&gt; &#123; const url = document.location.href window._bd_share_config = &#123; common: &#123; bdSnsKe: &#123;&#125;, bdMini: '2', bdStyle: '0', bdSize: '32', bdUrl: url, bdPic: img, bdText: text, bdDesc: desc, &#125;, share: &#123;&#125;, selectShare: &#123; bdContainerClass: null, bdSelectMiniList: ['qzone', 'tsina', 'popup_tqq', 'renren'], viewSize: '32', &#125;, &#125; const bdScript = document.createElement('script') bdScript.setAttribute('src', `http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion=$&#123;new Date().getTime()&#125;`) document.getElementsByTagName('head')[0].appendChild(bdScript)&#125;export default share 分享媒体id对应表123456789101112131415161718192021222324252627282930313233343536373839404142名称 ID印象笔记 evernotecn网易热 h163一键分享 mshareQQ空间 qzone新浪微博 tsina人人网 renren腾讯微博 tqq百度相册 bdxc开心网 kaixin001腾讯朋友 tqf百度贴吧 tieba豆瓣网 douban百度新首页 bdhomeQQ好友 sqq和讯微博 thx百度云收藏 bdysc美丽说 meilishuo蘑菇街 mogujie点点网 diandian花瓣 huaban堆糖 duitang和讯 hx飞信 fx有道云笔记 youdao麦库记事 sdo轻笔记 qingbiji人民微博 people新华微博 xinhua邮件分享 mail我的搜狐 isohu摇篮空间 yaolan若邻网 wealink天涯社区 tyFacebook fbookTwitter twilinkedin linkedin复制网址 copy打印 print百度中心 ibaidu微信 weixin股吧 iguba]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>百度分享</tag>
        <tag>bdshare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F08%2F28%2Fweb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化1.减少http请求 1.图片 2.样式 3.脚本 2.压缩组件 前端 1.css文件 and js脚本的内容压缩，图片压缩服务端 1.启用GZIP编码来压缩http响应包的大小。通过HTTP请求中的Accept-Encoding头来标识对压缩的支持 1Accept-Encoding: gzip,deflate 3.样式表放在顶部4.将脚本放在底部5.避免css表达式例如：1width:expression(setCntr(),document.body.clientWidth&lt;600?"600px":"auto"); 6.精简JavaScript例如：避免使用过多额全局遍历，避免过多的dom操作,缓存查找到的DOM元素 7.配置ETagETag 全称为：Entity Tag，意思是实体标签。 作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）来请求的时候，可以比较，如果ETag一致，则表示该资源并没有修改过，客户端（浏览器）可以使用自己缓存的版本。最终目的：缓存内容减少HTTP请求。 8.使Ajax可缓存使Ajax可缓存的前提是保证你的数据是不经常变化的，如果发生变化就重新从服务器请求新的数据 关于Ajax，我建议通过Ajax请求的内容仅包含必须从服务端返回的数据信息，HTML结构部分则缓存到HTML页面当中，然后通过模版解析，把所通过ajax请求的内容展示出来，因为目前浏览器端的运算速度越来越快了，所以现在完全可以这样做。 9.http缓存分类 强制缓存 在缓存数据未失效的情况下，不需要再和服务器发生交互 Expires 我们在demo.js中添加了一个Expires响应头，不过由于是格林尼治时间，所以通过momentjs转换一下。第一次请求的时候还是会向服务器发起请求，同时会把过期时间和文件一起返回给我们；但是当我们刷新的时候，才是见证奇迹的时刻：可以看出文件是直接从缓存（memory cache）中读取的，并没有发起请求。我们在这边设置过期时间为两分钟，两分钟过后可以刷新一下页面看到浏览器再次发送请求了。 虽然这种方式添加了缓存控制，节省流量，但是还是有以下几个问题的： 由于浏览器时间和服务器时间不同步，如果浏览器设置了一个很后的时间，过期时间一直没有用缓存过期后，不管文件有没有发生变化，服务器都会再次读取文件返回给浏览器 不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。 Cache-Control针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。 123456app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js'); let cont = fs.readFileSync(jsPath); res.setHeader('Cache-Control', 'public,max-age=120') //2分钟 res.end(cont)&#125;) 协商缓存需要进行比较判断是否可以使用缓存 强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。 Last-Modified为了节省服务器的资源，再次改进方案。浏览器和服务器协商，服务器每次返回文件的同时，告诉浏览器文件在服务器上最近的修改时间。请求过程如下： 浏览器请求静态资源demo.js服务器读取磁盘文件demo.js，返给浏览器，同时带上文件上次修改时间 Last-Modified（GMT标准格式）当浏览器上的缓存文件过期时，浏览器带上请求头If-Modified-Since（等于上一次请求的Last-Modified）请求服务器服务器比较请求头里的If-Modified-Since和文件的上次修改时间。如果果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和Last-Modified。循环请求。。12345678910111213141516app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js') let cont = fs.readFileSync(jsPath); let status = fs.statSync(jsPath) let lastModified = status.mtime.toUTCString() if(lastModified === req.headers['if-modified-since'])&#123; res.writeHead(304, 'Not Modified') res.end() &#125; else &#123; res.setHeader('Cache-Control', 'public,max-age=5') res.setHeader('Last-Modified', lastModified) res.writeHead(200, 'OK') res.end(cont) &#125;&#125;) 虽然这个方案比前面三个方案有了进一步的优化，浏览器检测文件是否有修改，如果没有变化就不再发送文件；但是还是有以下缺点： 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件如果服务器上文件被多次修改了但是内容却没有发生改变，服务器需要再次重新返回文件。 ETag浏览器请求静态资源demo.js服务器读取磁盘文件demo.js，返给浏览器，同时带上文件的唯一标识ETag当浏览器上的缓存文件过期时，浏览器带上请求头If-None-Match（等于上一次请求的ETag）请求服务器服务器比较请求头里的If-None-Match和文件的ETag。如果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和ETag。循环请求。。12345678910111213141516const md5 = require('md5');app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js'); let cont = fs.readFileSync(jsPath); let etag = md5(cont); if(req.headers['if-none-match'] === etag)&#123; res.writeHead(304, 'Not Modified'); res.end(); &#125; else &#123; res.setHeader('ETag', etag); res.writeHead(200, 'OK'); res.end(cont); &#125;&#125;) 缓存的优先级两种缓存规则可以同时存在，强制缓存优先级高于协商缓存。Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified参考资料 前端也要懂Http缓存机制]]></content>
      <categories>
        <category>ssh key</category>
      </categories>
      <tags>
        <tag>web性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在同一台Mac上，使用多个邮箱，配置多个ssh key]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8F%B0Mac%E4%B8%8A%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E9%82%AE%E7%AE%B1%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key%2F</url>
    <content type="text"><![CDATA[前言介绍 自己开始用自己的邮箱，注册了ssh key，将公钥添加到了github上，但现在公司要求使用企业邮箱生成公钥，将使用公司的企业邮箱生成的公钥添加到自己公司搭建的gitlab私服上，由此以来开始了下面的折腾。同时使用多个邮箱，注册多个公钥。 1.先使用自己的邮箱生成第一个key12// 在终端中执行ssh-keygen -t rsa -C "yourEmail@xxx.com" 第一个key一路回车,生成以后，在终端中执行下面命令进行查看 1open ~/.ssh 此时，.ssh文件中多个两个文件 id_rsa 私钥，id_rsa.pub 2.在使用公司邮箱生成第二个key12// 在终端中执行ssh-keygen -t rsa -C "companyEmail@xxx.com" 回车以后：在下面的操作中，给第二个key取一个名字，用于区分。如果一路回车会覆盖掉第一次生成的秘钥。 1Enter file in which to save the key (/Users/Shinancao/.ssh/id_rsa): id_rsa_customName 现在，再执行命令 open ~/.ssh命令，我们能看到 .ssh文件中又多了两个秘钥 3.在.ssh文件夹中创建一个config文件 1vim ~/.ssh/config 配置config 12345678910111213141516# githubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser github注册的用户名# custome-gitlabHost company // 别名HostName 192.168.11.XXX // 公司服务器ipport 10080 // 端口号PreferredAuthentications publickey // 强制使用Public Key验证IdentityFile ~/.ssh/id_rsa_nyso // 密钥文件的路径User 注册的用户名 4.使用的过程会报错，那是因为我们还没有加载刚才的配置1234567//查看当前rsa listssh-add -l //如果列表中没有新增的rsa， 添加identifilessh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_customName// 再去操作就没有问题了 5.设置全局的用户名和邮箱12git config --global user.name "your name"git config --global user.email "your email" 6.查看配置的结果12git config --global user.namegit config --global user.email 7.设置全局后默认都是，全局配置用户名和邮箱。如果我们想针对不同的仓库，使用不同的用户名和邮箱呢？1234567891011// 先取消全局设置git config --global --unset user.namegit config --global --unset user.email// 再进入项目目录下设置git config user.email "your name"git config user.email "your email"// 查看配置结果git config user.namegit config user.email 8.大功告成，可以下班回家喽。😁]]></content>
      <categories>
        <category>ssh key</category>
      </categories>
      <tags>
        <tag>ssh key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac电脑上使用tree生成目录结构]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%9C%A8Mac%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8tree%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[生成markdown文件的目录结构，先上效果图12345678910111213141516171819202122232425262728293031323334353637383940.├── build│ ├── build.js│ ├── check-versions.js│ ├── logo.png│ ├── utils.js│ ├── vue-loader.conf.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── index.html├── package.json├── src│ ├── api│ │ └── index.js│ ├── assets│ │ ├── images│ │ └── stylus│ ├── components│ │ ├── checkbox│ │ ├── index.js│ │ ├── radio│ │ └── topbar│ ├── index.js│ ├── main.js│ ├── mixins│ ├── router│ │ ├── index.js│ │ └── routes│── └── views│ ├── App.vue│ ├── index│ └── ui├── static│ └── .gitkeep└── tree.md 1. Mac下使用brew install tree进行安装。安装之后在终端里，输入 tree -a 就可以查看当前目录下的缩影文件。 使用brew的时候，每次都会进行检查更新。每次更新特别慢，怎么把它给禁掉呢 1export HOMEBREW_NO_AUTO_UPDATE=true 在终端中执行这行代码后就能禁掉，现在试试就不再自动更新了。 2. tree的常用命令行参数 -a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用”?”号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 3. 我们根据自己的项目来实际操作一下1tree -L 3 -I "node_modules" &gt; tree.md 上面命令意思是显示项目下3层的所有文件结构，同时忽略node_modules文件夹，最后输出到tree.md]]></content>
      <categories>
        <category>tree</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建自己的npm包]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85%EF%BC%8C%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[为什么要使用NPM NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功: 15.6.0 1. 先在本地构建一个demo的项目，创建index.js文件1234// index.jsmodule.exports.helloWorld = function() &#123; return 'Hello World!'&#125; 2. npm 初始化创建package.json文件1npm init 3. 先在npmjs官网上注册一个自己的账号 注册成功后，打开命令行工具。1npm login 根据命令提示输入用户名密码，登录后可以查询自己的账号 1npm whoami 4. 这些做完准备工作就都准备完了，现在开始上传npm包 cmd进入demo目录，执行下面命令1npm publish 如果第一次名称没有冲突和符合npm命名规范的话，就直接上传成功了 特别注意，每次发包都要更改版本号 5.使用npm包1234// 先安装刚刚上传的包npm i test-package-name --save-dev// 再引用let test = require('test-package-name') 6.定义作用于模块 防止构建新包命名时和别人的重复，造成发布失败。我们使用自己的用户名定义一个作用域，每个npm用户都有一个以自己名为作用域。 1@username/project-name 7.发布作用模块1@username/project-name 报错了，什么鬼。 原来携带头的npm作用域默认发的是私有包，要想成功发包，添加access=public参数，发布成为公用包 1npm publish --access=public]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTem2 + oh my zsh + agnoster 打造自己的终端工具]]></title>
    <url>%2F2018%2F07%2F06%2FiTem2-oh-my-zsh-agnoster-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1. 安装iTem2iTerm2传送门，选择要下载的安装包 2. oh-my-zsh介绍 oh-my-zsh是基于zsh的功能做了一个扩展，方便的插件管理、主题自定义，以及漂亮的自动完成效果 安装zsh12brew install zsh// 出现这个画面后就代码安装成功 没有安装homebrew的先安装一下homebrew官网 复制下面命令，在终端中输入：1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" brew 安装插件的时候默认都会进行更新，这个是特别慢的毕竟有道墙，手动设置关闭自动更新，在终端中执行下面代码。 1export HOMEBREW_NO_AUTO_UPDATE=true 查看当前默认bash，修改默认shell1chsh -s /bin/zsh 修改完之后验证是否修改成功12echo $SHELL// 此时终端打印出 /bin/zsh 恭喜你设置成功 下载安装PowerFonts字体123456# git clonegit clone https://github.com/powerline/fonts.git --depth=1# cd to foldercd fonts# run install shell./install.sh 安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好： 配置agnoster主题安装成功之后，我们可以通过vi ~/.zshrc，设置ZSH_THEME=”agnoster”对主题进行修改。 最终效果图 命令补全123456789cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-autosuggestionsvi ~/.zshrc// 找到plugins，修改内容plugins=( git zsh-autosuggestions)// 默认打开里面已经有一个git 效果展示 安装高亮插件123456789cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitvi ~/.zshrc// 找到plugins，修改内容plugins=( git zsh-autosuggestions zsh-syntax-highlighting) zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：1source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 按一下esc调出vi命令，输入:wq保存并退出vi模式。 执行命令使刚才的修改生效：1source ~/.zshrc 配置完成]]></content>
      <categories>
        <category>iTem2</category>
      </categories>
      <tags>
        <tag>iTem2</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.创建数组的两个基本方式1234// 1. 使用Array构造函数let person = new Array()// 2. 使用字面量表示法let person = ['name', 'age'] 2. 判断是否为数组类型123456789// 1. 使用instanceof判断let num = [1, 3, 5, 7]console.log(num instanceof Array) // true// 2. constructor 判断console.log(num.constructor === Array) // true// 3. 现获取内部的属性，返回一个字符串，再利用call，达到检测数组的目的,综合考虑推荐这种写法console.log(Object.prototype.toString.call(num) === '[object Array]') // true// 4. Array.isArrayconsole.log(Array.isArray(num)) // true 3. 数组中的常用方法(只列出常用的) push() pop() unshift() shift() splice()1234567891011121314151617181920212223242526272829303132333435// push()方法可以接受任意参数，逐个添加到数组尾部，并返回添加后的数组长度，该数组也会修改原数组。let arr = [1]console.log(arr.push(2)) // arr =&gt; [1, 2]console.log(arr.push('three')) // arr =&gt; [1, 'three']console.log(arr.push(&#123; a: 3 &#125;)) // arr =&gt; [1, &#123; a: 3 &#125;]console.log(arr.push([2, 3])) // arr =&gt; [1, [2, 3]]// pop() 从数组末尾移除最后一项，减少数组的长度，然后返回移除的项，并且会改变原来的数组let brow = ['Google', 'Baidu', '360']console.log(brow.pop()) // brow =&gt; ['Google', 'Baidu']// shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。let arr = [1, 3, 5, 7]console.log(arr.shift()) // arr =&gt; [3, 5, 7]/* * splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 * array.splice(start, deleteCount, item1,...itemX) * start :必须 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始* 的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的* 元素。 * deleteCount 可选 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如* 果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 * item1...itemX 可选要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 */ let arr = [1, 2, 3, 4, 5, 6, 7]// 从第2位开始删除0个元素，插入“drum” arr.splice(2, 0, 'a') //arr =&gt; [1, 2, "a", 3, 4, 5, 6, 7]// 从第3位开始删除1个元素arr.splice(3, 1) //arr =&gt; [1, 2, 3, 5, 6, 7]// 从第2位开始删除1个元素，然后插入“temp”arr.splice(2, 1, 'temp') //arr =&gt; [1, 2, 'temp', 4, 5, 6, 7]// 从第0位开始删除2个元素，然后插入"a1","a2"和"a3"arr.splice(0, 2, 'a1', 'a2', 'a3') //arr =&gt; ['a1', 'a2', 'a3', 3, 4, 5, 6, 7]// 从第2位开始删除2个元素arr.splice(arr.length - 3, 2) // arr =&gt; [1, 2, 5, 6, 7]// 从第2位开始删除所有元素arr.splice(2) // arr =&gt; [1, 2] 4. 可能遇到的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 将数组中的数字相加求和let arr = [1, 2, 3, 4, 5, 6, 7]console.log(eval(arr.join('+')))// 模拟后端返回的数据格式let result = &#123; code: '200', data: [ &#123; id: 123, name: 'a1', age: 25 &#125;, &#123; id: 456, name: 'a2', age: 26 &#125;, &#123; id: 789, name: 'a3', age: 27 &#125; ]&#125;// 判断后端返回数据中是否存在id为456的数据const filter1 = function(id) &#123; let obj = [] const data = result.data data.forEach((item) =&gt; &#123; let id = item.id obj.push(id) &#125;) return obj.indexOf(id) &gt; -1 ? true : false&#125;filter1(456) // =&gt; truefilter1(4566) // =&gt; false// 获取id为456的数据const filterData = function (id) &#123; let obj = &#123;&#125; const data = result.data data.forEach((item) =&gt; &#123; let id = item.id obj[id] = item &#125;) return obj[id] ? obj[id] : []&#125;filterData(456) // =&gt; &#123;id: 456, name: "a2", age: 26&#125;filterData(4566) // =&gt; []]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue脚手架vue-cli配置多页面应用]]></title>
    <url>%2F2018%2F05%2F05%2Fvue%E9%A1%B9%E7%9B%AEwebpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[webpack常用插件 html-webpack-plugin // 生成一个html文件 clean-webpack-plugin // 清除dist文件夹中重复的文件 webpack-merger // 合并webpack配置文件 webpack-dev-server // 热启动 extract-text-webpack-plguin // 抽取样式文本 1.配置多入口123456789101112131415161718192021222324// utils.js// 查找符合特定规则的文件路径名var glob = require('glob')//获取多级的入口文件exports.getMultiEntry = function (globPath) &#123; var entries = &#123;&#125;, basename, tmp, pathname; glob.sync(globPath).forEach(function (entry) &#123; basename = path.basename(entry, path.extname(entry)); tmp = entry.split('/').splice(-4); var pathsrc = tmp[0] + '/' + tmp[1]; if (tmp[0] == 'src') &#123; pathsrc = tmp[1]; &#125; pathname = pathsrc + '/' + basename; // 正确输出js和html的路径 entries[pathname] = entry; &#125;); return entries;&#125; 2. 在webpack.base.conf.js中赋值给entry123456const utils = require('./utils')// 多页面设置入口文件const entries = utils.getMultiEntry('./src/' + config.moduleName + '/**/**/*.js');module.exports = &#123; entry: entries,&#125; 3. 构建生成多页面的HtmlWebpackPlugin配置12345678910111213141516// webpack.dev.conf.js webpack.prod.conf.js分别在webpack.dev.conf.js 和webpack.prod.conf.js中设置var pages = utils.getMultiEntry('./src/' + config.moduleName + '/**/**/*.html');for (var pathname in pages) &#123; var conf = &#123; filename: pathname + '.html', template: pages[pathname], // 模板路径 chunks: ['vendor', pathname], // 每个html引用的js模块 inject: true, // js插入位置 hash: true &#125;; webpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125;module.exports = webpackConfig 4. 简单的几步走，具体细节看项目代码使用vue脚手架vue-cli配置多页面应用]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Object]]></title>
    <url>%2F2018%2F02%2F01%2Fobject%2F</url>
    <content type="text"><![CDATA[1.创建对象的几种方法1.1创建对象的最简单的方法就是使用对象直接量1var emptyObj = &#123;&#125;; 1.2 通过new创建对象1var emptyObj = new Object(); 1.3 Object.create(prototype, [propertyObject])使用Object.create()创建一个新对象，其中第一个参数是对象的原型，第二个是可选参数，用于对对象的属性进行进一步的描述。propertyObject 为null时新创建的对象就不包括所有的属性和方法 var obj = Object.create(null) obj.toString =&gt; undefined Object.create应用场景(实现继承)1234567891011121314function Person() &#123;&#125;function Student() &#123;&#125; // 这样做的好处是修改子类的属性不会对父类造成影响，可以在Student实现自己的属性和方法，但有一点Object.create是ES5的时候才有的方法，不兼容低版本，如果想要使用Object.create可以事先判断一下Student.prototype = Object.create(Person.prototype)if (!Object.create) &#123; Object.create = function (proto) &#123; function N () &#123;&#125; N.prototype = proto; return N; &#125;&#125;// 对上面的继承进行扩展，有一种更加便利的方式;// 将Student原型对象中的构造函数指向PersonStudent.prototype.constructor = Person 对象中的getter setter方法1234567891011121314151617181920212223242526272829303132var objs = &#123; name: 'Bruce', get deelName() &#123; return this.name &#125;, set deelName(val) &#123; this.name = val &#125;&#125;// 获取属性值 objs.deelName =&gt; Bruce// 为对象属性赋值 objs.deelName = 'test'// 验证赋值=&gt; 'test'// objs.name =&gt; 'test'// 对象已有的属性添加特性描述var book = &#123; _year: 2004,&#125;Object.defineProperty(book, 'year', &#123; configurable: true, // 默认为true 是否可以配置（删除、修改、访问） enumerable: true, // 默认true 是否能枚举for-in writable: true, // 默认true 是否能修改属性的值 get: function() &#123; return this._year &#125;, set: function(newval) &#123; this._year = newval &#125;&#125;)// book.year =&gt; 2004// book.year = 2005// book.year =&gt; 2005]]></content>
      <categories>
        <category>Object</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum操作常用命令]]></title>
    <url>%2F2018%2F01%2F31%2Fyum-not%2F</url>
    <content type="text"><![CDATA[列出所有已安装的软件包1yum list installed yum针对软件包操作常用命令：1.使用YUM查找软件包1yum search 2.列出所有可安装的软件包1yum list 3.列出所有可更新的软件包1yum list updates 4.列出所有已安装的软件包1yum list installed 5.列出所有已安装但不在 Yum Repository 内的软件包1yum list extras 6.列出所指定的软件包1yum list 7.使用YUM获取软件包信息1yum info 8.列出所有软件包的信息1yum info 9.列出所有可更新的软件包信息1yum info updates 10.列出所有已安装的软件包信息1yum info installed 11.列出所有已安装但不在 Yum Repository 内的软件包信息1yum info extras 12.列出软件包提供哪些文件1yum provides]]></content>
      <categories>
        <category>yum</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F01%2F29%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.命令的基本格式命令 选项 参数 ls -a 全部文件/包括隐藏文件 ls -l 显示详细信息ls -d 查看目录属性ls -i 显示inodels -lh 显示文件的字节大小 rw -r - - r - - 文件类型 （ - 文件 d 目录 i软链接文件）rw- r - - r - -u所有者 g所属组 o其他人r 读 w写 x执行 2.目录处理命令根目录和家目录是两个不同的概念 mkdir -p 目录-p 递归创建 cd+enter 进入当前用户的家目录cd ~ 进入当前用户的家目录cd - 进入上次目录cd .. 进入上一级目录cd . 进入当前目录 相对路径：参照的是我当前的目录绝对路径：具体的目标路径 按连续两次tab键：命全补充和目录补全pwd：打印当前位置的工作路径 3.删除文件或目录rm -rf 文件/目录 -r 删除目录-f 强制 4.复制文件或目录cp -r 原文件或目录 目标目录 -p 连带文件属性复制 -d 若源文件是链接文件，则复制链接属性 -a 相当于pdr 5.剪切或者改名命令mv 源文件或者目录 目标目录 6.目录介绍根目录下的bin和sbin， usr目录下的bin和sbin，这四个目录都是用来保存系统命令的。bin和sbin的区分：bin： 任何用户都可以执行sbin：只有root用户才能执行boot: 启动目录dev: 特殊文件保存目录lib: 函数库目录sys 和 proc: proc和sys目录不能直接操作，这两个目录保存的是内存的过载点。usr：系统软件资源目录var：系统相关命令media met misc 空目录 7.文件搜索命令 文件搜索命令locate(执行没有命令执行时需要安装 yum install locate)locate 文件名在后台数据库中按文件名搜索，搜索速度更快 /var/lib/mlocatelocate命令所搜索的后台数据库 updated更新数据库/etc/updatedb.conf 配置文件 命令搜索命令whereis与which whereis 命令名搜索命令所在路径及帮助文档所在位置 -b: 只查找可执行文件-m:只查找帮助文件 which 命令名 搜索命令所在路径及别名 文件搜索命令find find 搜索范围 搜索条件find / -name filelog.log find 是在系统中搜索符合条件的文件名，如果需要匹配，s会用通配符匹配，通配符是完全匹配。 find / -iname filelog.log 加i忽略大小写 find / -user root 按照所有者搜索 Linux中的通配符 匹配任意内容？匹配任意一个字符[] 匹配任意一个中括号内的字符]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac环境下使用瓶子（Charles）抓包Https请求]]></title>
    <url>%2F2017%2F12%2F19%2FCharles%2F</url>
    <content type="text"><![CDATA[Charles 根证书配置1.选择 Charles 菜单“Help”-&gt;“SSL Proxying”-&gt;“Install Charles Root Certificate”2.接着会自动弹出‘钥匙串访问’，默认情况下 Charles Proxy CA证书不会被信任的，右键选择显示简介将证书修改为始终信任 SSL Proxying Settings选择菜单中“Proxy”-&gt;“SSL Proxying Settings…”添加使用通配符 Host Port ，表示抓取所有地址与端口的HTTPS请求 给手机安装证书 设置手机代理（IP地址为电脑ip），端口号为Proxy &gt; Proxies &gt; HTTP Proxy 中设置的端口号 打开Charles，在Menu选择Help &gt; SSL Proxying &gt; Install Charles Root Certificate on a Mobile Device or Remote Browse弹出一个弹框，根据提示使用手机访问地址： chls.pro/ssl 给手机安装证书 安卓手机需要注意（Android设备安装.pem证书文件） Android设备，只有部分设备的默认浏览器会识别.pem这个格式，而其他浏览器和一些机型不能自己安装这个文件。需要在设置中找到，类似于 安全与隐私，这一项，然后从存储设备中安装。 最后别忘了在手机中将瓶子证书设置为信任，不然请求就会一直返回unknown设置–&gt;通用–&gt;关于本机–&gt;证书信任设置把里面的那个Charles的证书设置为信任就可以了]]></content>
      <categories>
        <category>Charles</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>mac Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm常用操作]]></title>
    <url>%2F2017%2F11%2F17%2Fnvm%2F</url>
    <content type="text"><![CDATA[1.安装nvm命令github.com nvm wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 2.核实nvm是否安装成功，安装成功后执行命令返回’nvm’1command -v nvm 3.检查当前支持什么版本1nvm ls-remote 4.指定安装版本1nvm install vx.x.x 5.安装最新稳定版本1nvm install stable 6.删除某版本的node12nvm uninstall 4.4.0nvm uninstall default 7.nvm使用default的alias来实现默认版本,执行命令1nvm alias default vx.x.x 8.查看当前已经安装的版本1nvm ls 9.以指定版本执行脚本1nvm use v8.8.1 app.js 10.卸载nvm1rm -rf ~/.nvm 11.切换至x.x.x版本1nvm use vx.x.x 12.查看正在使用的版本1nvm current]]></content>
      <categories>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>mac nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac电脑终端使用scp上传/下载文件/文件夹]]></title>
    <url>%2F2017%2F11%2F15%2Fremote-scp%2F</url>
    <content type="text"><![CDATA[1.从服务器下载文件到本地电脑1scp -r remote_username@remote_ip:remote_folder local_folder 例如： 1scp -r root@106.xx.xxx.xx:/root/www/file /Desktop/folder 2.从本地上传文件到服务器1scp -r local_folder remote_username@remote_ip:remote_folder 例如： 1scp -r /Desktop/folder root@106.xx.xxx.xx:/root/www/file 3.上传和下载文件就是把这种格式来回调换一下]]></content>
      <categories>
        <category>scp</category>
      </categories>
      <tags>
        <tag>scp</tag>
        <tag>mac scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用mac终端将本地文件上传到服务器上]]></title>
    <url>%2F2017%2F11%2F15%2Fremote-shell%2F</url>
    <content type="text"><![CDATA[1.打开本地终端，使用菜单中Shell2.使用菜单中Shell 选择 “新建远程连接”3.进入“新建远程连接控制面板”后左侧服务选择“安全文件传输（sftp）”右侧服务器端添加自己的服务器连接ip地址，同时输入要使用的“用户”身份选择登录。4.开始上传本地文件，上传文件之前需要把文件在本地进行压缩 put 本地文件的地址链接 要上传到服务器的位置 1put Desktop/www/file.zip /www/file 5.在服务上对已上传的压缩文件进行解压 切换到文件当前目录下执行命令： 1unzip file.zip]]></content>
      <categories>
        <category>mac</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>mac shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express 路由(Router)]]></title>
    <url>%2F2016%2F10%2F29%2Fexpress-router%2F</url>
    <content type="text"><![CDATA[基本路由1.路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。路由定义采用以下结构： 1app.METHOD(PATH, HANDLER) 其中：app 是 express 的实例。METHOD 是 HTTP 请求方法。PATH 是服务器上的路径。HANDLER 是在路由匹配时执行的函数。 2.在根路由 (/) 上（应用程序的主页）对 POST 请求进行响应：123app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user');&#125;); 有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。在以下示例中，无论您使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法，都将为针对“/secret”的请求执行处理程序。 1234app.all('/secret', function (req, res, next) &#123;console.log('Accessing the secret section ...');next(); // pass control to the next handler&#125;); 路由路径路由路径与请求方法相结合，用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。 Express 使用 path-to-regexp 来匹配路由路径；请参阅 path-to-regexp 文档以了解定义路由路径时所有的可能性。Express Route Tester 是用于测试基本 Express 路由的便捷工具，但是它不支持模式匹配。 以下是基于字符串的路由路径的一些示例。 此路由路径将请求与根路由 / 匹配。 123app.get('/', function (req, res) &#123; res.send('root');&#125;); 此路由路径将请求与 /about 匹配。 123app.get('/about', function (req, res) &#123; res.send('about');&#125;); 字符 ?、+、* 和 () 是其正则表达式同应项的子集。基于字符串的路径按字面理解连字符 (-) 和点 (.)。 express.Router使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。 以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。 在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容： 12345678910111213141516var express = require('express');var router = express.Router();// middleware that is specific to this routerrouter.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// define the home page routerouter.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// define the about routerouter.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 接着，在应用程序中装入路由器模块：123var birds = require('./birds');...app.use('/birds', birds); 此应用程序现在可处理针对 /birds 和 /birds/about 的请求，调用特定于此路由的 timeLog 中间件函数。]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>express.Router</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue filter]]></title>
    <url>%2F2016%2F10%2F10%2Fvue-filter%2F</url>
    <content type="text"><![CDATA[Vue过滤器的基本使用html部分123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--插值中的表达式--&gt; &lt;input type="text" v-model="msg"&gt; &lt;h2&gt;&#123;&#123; msg ? 'YES' : 'NO' &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; msg.split('').reverse().join('') | uppercase &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; number + 1 | currency '₫' 0 &#125;&#125;&lt;/h2&gt; &lt;!--自定义过滤器--&gt; &lt;h2&gt; &#123;&#123; filterParam | customFilter&#125;&#125;&lt;/h2&gt; &lt;!-- 1.limitBy - test 2.限制只显示数字中前两条数据 --&gt; &lt;ul&gt; &lt;li v-for="item in dataArray | limitBy 2"&gt;name: &#123;&#123; item.name &#125;&#125;----age: &#123;&#123; item.age &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 1.filterBy - test 2.过滤出对象中name属性字段含有‘Chuck’值的数据，并且只显示该数据 3.in 后面可以跟多字段进行搜索 --&gt; &lt;ul&gt; &lt;li v-for="item in dataArray | filterBy 'Chuck123' in 'name' 'temp'"&gt;name: &#123;&#123; item.name &#125;&#125;----age: &#123;&#123; item.age &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; js部分12345678910111213141516171819202122/** * 1.split 将字符串分割成数组 * 2.filter 接受两个参数，第一个是自定义名称，第二个是一个函数，并将值作为参数使用最后返回处理后的值 * 3.reverse 用于颠倒数组之前的顺序 * join 将数组按照指定分隔符进行分割，并返回一个字符串 * */ Vue.filter('customFilter', function(value) &#123; return value.split('').reverse().join('') &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'world', number: 148547, filterParam: 'small text!', dataArray: [ &#123;'name': 'Bruce', 'age': 1&#125;, &#123;'name': 'Chuck', 'age': 2, 'temp': 'Chuck123'&#125;, &#123;'name': 'Jack', 'age': 3&#125;, ] &#125; &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-filter</tag>
      </tags>
  </entry>
</search>
