<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F08%2F28%2Fweb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化1.减少http请求 1.图片 2.样式 3.脚本 2.压缩组件 前端 1.css文件 and js脚本的内容压缩，图片压缩服务端 1.启用GZIP编码来压缩http响应包的大小。通过HTTP请求中的Accept-Encoding头来标识对压缩的支持 1Accept-Encoding: gzip,deflate 3.样式表放在顶部4.将脚本放在底部5.避免css表达式例如：1width:expression(setCntr(),document.body.clientWidth&lt;600?"600px":"auto"); 6.精简JavaScript例如：避免使用过多额全局遍历，避免过多的dom操作,缓存查找到的DOM元素 7.配置ETagETag 全称为：Entity Tag，意思是实体标签。 作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）来请求的时候，可以比较，如果ETag一致，则表示该资源并没有修改过，客户端（浏览器）可以使用自己缓存的版本。最终目的：缓存内容减少HTTP请求。 8.使Ajax可缓存使Ajax可缓存的前提是保证你的数据是不经常变化的，如果发生变化就重新从服务器请求新的数据 关于Ajax，我建议通过Ajax请求的内容仅包含必须从服务端返回的数据信息，HTML结构部分则缓存到HTML页面当中，然后通过模版解析，把所通过ajax请求的内容展示出来，因为目前浏览器端的运算速度越来越快了，所以现在完全可以这样做。 9.http缓存分类 强制缓存 在缓存数据未失效的情况下，不需要再和服务器发生交互 Expires 我们在demo.js中添加了一个Expires响应头，不过由于是格林尼治时间，所以通过momentjs转换一下。第一次请求的时候还是会向服务器发起请求，同时会把过期时间和文件一起返回给我们；但是当我们刷新的时候，才是见证奇迹的时刻：可以看出文件是直接从缓存（memory cache）中读取的，并没有发起请求。我们在这边设置过期时间为两分钟，两分钟过后可以刷新一下页面看到浏览器再次发送请求了。 虽然这种方式添加了缓存控制，节省流量，但是还是有以下几个问题的： 由于浏览器时间和服务器时间不同步，如果浏览器设置了一个很后的时间，过期时间一直没有用缓存过期后，不管文件有没有发生变化，服务器都会再次读取文件返回给浏览器 不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。 Cache-Control针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。 123456app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js'); let cont = fs.readFileSync(jsPath); res.setHeader('Cache-Control', 'public,max-age=120') //2分钟 res.end(cont)&#125;) 协商缓存需要进行比较判断是否可以使用缓存 强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。 Last-Modified为了节省服务器的资源，再次改进方案。浏览器和服务器协商，服务器每次返回文件的同时，告诉浏览器文件在服务器上最近的修改时间。请求过程如下： 浏览器请求静态资源demo.js服务器读取磁盘文件demo.js，返给浏览器，同时带上文件上次修改时间 Last-Modified（GMT标准格式）当浏览器上的缓存文件过期时，浏览器带上请求头If-Modified-Since（等于上一次请求的Last-Modified）请求服务器服务器比较请求头里的If-Modified-Since和文件的上次修改时间。如果果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和Last-Modified。循环请求。。12345678910111213141516app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js') let cont = fs.readFileSync(jsPath); let status = fs.statSync(jsPath) let lastModified = status.mtime.toUTCString() if(lastModified === req.headers['if-modified-since'])&#123; res.writeHead(304, 'Not Modified') res.end() &#125; else &#123; res.setHeader('Cache-Control', 'public,max-age=5') res.setHeader('Last-Modified', lastModified) res.writeHead(200, 'OK') res.end(cont) &#125;&#125;) 虽然这个方案比前面三个方案有了进一步的优化，浏览器检测文件是否有修改，如果没有变化就不再发送文件；但是还是有以下缺点： 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件如果服务器上文件被多次修改了但是内容却没有发生改变，服务器需要再次重新返回文件。 ETag浏览器请求静态资源demo.js服务器读取磁盘文件demo.js，返给浏览器，同时带上文件的唯一标识ETag当浏览器上的缓存文件过期时，浏览器带上请求头If-None-Match（等于上一次请求的ETag）请求服务器服务器比较请求头里的If-None-Match和文件的ETag。如果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和ETag。循环请求。。12345678910111213141516const md5 = require('md5');app.get('/demo.js',(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,'./static/js/demo.js'); let cont = fs.readFileSync(jsPath); let etag = md5(cont); if(req.headers['if-none-match'] === etag)&#123; res.writeHead(304, 'Not Modified'); res.end(); &#125; else &#123; res.setHeader('ETag', etag); res.writeHead(200, 'OK'); res.end(cont); &#125;&#125;) 缓存的优先级两种缓存规则可以同时存在，强制缓存优先级高于协商缓存。Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified参考资料 前端也要懂Http缓存机制]]></content>
      <categories>
        <category>ssh key</category>
      </categories>
      <tags>
        <tag>web性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在同一台Mac上，使用多个邮箱，配置多个ssh key]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8F%B0Mac%E4%B8%8A%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E9%82%AE%E7%AE%B1%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key%2F</url>
    <content type="text"><![CDATA[前言介绍 自己开始用自己的邮箱，注册了ssh key，将公钥添加到了github上，但现在公司要求使用企业邮箱生成公钥，将使用公司的企业邮箱生成的公钥添加到自己公司搭建的gitlab私服上，由此以来开始了下面的折腾。同时使用多个邮箱，注册多个公钥。 1.先使用自己的邮箱生成第一个key12// 在终端中执行ssh-keygen -t rsa -C "yourEmail@xxx.com" 第一个key一路回车,生成以后，在终端中执行下面命令进行查看 1open ~/.ssh 此时，.ssh文件中多个两个文件 id_rsa 私钥，id_rsa.pub 2.在使用公司邮箱生成第二个key12// 在终端中执行ssh-keygen -t rsa -C "companyEmail@xxx.com" 回车以后：在下面的操作中，给第二个key取一个名字，用于区分。如果一路回车会覆盖掉第一次生成的秘钥。 1Enter file in which to save the key (/Users/Shinancao/.ssh/id_rsa): id_rsa_customName 现在，再执行命令 open ~/.ssh命令，我们能看到 .ssh文件中又多了两个秘钥 3.在.ssh文件夹中创建一个config文件 1vim ~/.ssh/config 配置config 12345678910111213141516# githubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser github注册的用户名# custome-gitlabHost company // 别名HostName 192.168.11.XXX // 公司服务器ipport 10080 // 端口号PreferredAuthentications publickey // 强制使用Public Key验证IdentityFile ~/.ssh/id_rsa_nyso // 密钥文件的路径User 注册的用户名 4.使用的过程会报错，那是因为我们还没有加载刚才的配置1234567//查看当前rsa listssh-add -l //如果列表中没有新增的rsa， 添加identifilessh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_customName// 再去操作就没有问题了 5.设置全局的用户名和邮箱12git config --global user.name "your name"git config --global user.email "your email" 6.查看配置的结果12git config --global user.namegit config --global user.email 7.设置全局后默认都是，全局配置用户名和邮箱。如果我们想针对不同的仓库，使用不同的用户名和邮箱呢？1234567891011// 先取消全局设置git config --global --unset user.namegit config --global --unset user.email// 再进入项目目录下设置git config user.email "your name"git config user.email "your email"// 查看配置结果git config user.namegit config user.email 8.大功告成，可以下班回家喽。😁]]></content>
      <categories>
        <category>ssh key</category>
      </categories>
      <tags>
        <tag>ssh key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac电脑上使用tree生成目录结构]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%9C%A8Mac%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8tree%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[生成markdown文件的目录结构，先上效果图12345678910111213141516171819202122232425262728293031323334353637383940.├── build│ ├── build.js│ ├── check-versions.js│ ├── logo.png│ ├── utils.js│ ├── vue-loader.conf.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── index.html├── package.json├── src│ ├── api│ │ └── index.js│ ├── assets│ │ ├── images│ │ └── stylus│ ├── components│ │ ├── checkbox│ │ ├── index.js│ │ ├── radio│ │ └── topbar│ ├── index.js│ ├── main.js│ ├── mixins│ ├── router│ │ ├── index.js│ │ └── routes│── └── views│ ├── App.vue│ ├── index│ └── ui├── static│ └── .gitkeep└── tree.md 1. Mac下使用brew install tree进行安装。安装之后在终端里，输入 tree -a 就可以查看当前目录下的缩影文件。 使用brew的时候，每次都会进行检查更新。每次更新特别慢，怎么把它给禁掉呢 1export HOMEBREW_NO_AUTO_UPDATE=true 在终端中执行这行代码后就能禁掉，现在试试就不再自动更新了。 2. tree的常用命令行参数 -a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用”?”号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 3. 我们根据自己的项目来实际操作一下1tree -L 3 -I "node_modules" &gt; tree.md 上面命令意思是显示项目下3层的所有文件结构，同时忽略node_modules文件夹，最后输出到tree.md]]></content>
      <categories>
        <category>tree</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建自己的npm包]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85%EF%BC%8C%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[为什么要使用NPM NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功: 15.6.0 1. 先在本地构建一个demo的项目，创建index.js文件1234// index.jsmodule.exports.helloWorld = function() &#123; return 'Hello World!'&#125; 2. npm 初始化创建package.json文件1npm init 3. 先在npmjs官网上注册一个自己的账号 注册成功后，打开命令行工具。1npm login 根据命令提示输入用户名密码，登录后可以查询自己的账号 1npm whoami 4. 这些做完准备工作就都准备完了，现在开始上传npm包 cmd进入demo目录，执行下面命令1npm publish 如果第一次名称没有冲突和符合npm命名规范的话，就直接上传成功了 特别注意，每次发包都要更改版本号 5.使用npm包1234// 先安装刚刚上传的包npm i test-package-name --save-dev// 再引用let test = require('test-package-name') 6.定义作用于模块 防止构建新包命名时和别人的重复，造成发布失败。我们使用自己的用户名定义一个作用域，每个npm用户都有一个以自己名为作用域。 1@username/project-name 7.发布作用模块1@username/project-name 报错了，什么鬼。 原来携带头的npm作用域默认发的是私有包，要想成功发包，添加access=public参数，发布成为公用包 1npm publish --access=public]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTem2 + oh my zsh + agnoster 打造自己的终端工具]]></title>
    <url>%2F2018%2F07%2F06%2FiTem2-oh-my-zsh-agnoster-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1. 安装iTem2iTerm2传送门，选择要下载的安装包 2. oh-my-zsh介绍 oh-my-zsh是基于zsh的功能做了一个扩展，方便的插件管理、主题自定义，以及漂亮的自动完成效果 安装zsh12brew install zsh// 出现这个画面后就代码安装成功 没有安装homebrew的先安装一下homebrew官网 复制下面命令，在终端中输入：1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" brew 安装插件的时候默认都会进行更新，这个是特别慢的毕竟有道墙，手动设置关闭自动更新，在终端中执行下面代码。 1export HOMEBREW_NO_AUTO_UPDATE=true 查看当前默认bash，修改默认shell1chsh -s /bin/zsh 修改完之后验证是否修改成功12echo $SHELL// 此时终端打印出 /bin/zsh 恭喜你设置成功 下载安装PowerFonts字体123456# git clonegit clone https://github.com/powerline/fonts.git --depth=1# cd to foldercd fonts# run install shell./install.sh 安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好： 配置agnoster主题安装成功之后，我们可以通过vi ~/.zshrc，设置ZSH_THEME=”agnoster”对主题进行修改。 最终效果图 命令补全123456789cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-autosuggestionsvi ~/.zshrc// 找到plugins，修改内容plugins=( git zsh-autosuggestions)// 默认打开里面已经有一个git 效果展示 安装高亮插件123456789cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitvi ~/.zshrc// 找到plugins，修改内容plugins=( git zsh-autosuggestions zsh-syntax-highlighting) zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：1source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 按一下esc调出vi命令，输入:wq保存并退出vi模式。 执行命令使刚才的修改生效：1source ~/.zshrc 配置完成]]></content>
      <categories>
        <category>iTem2</category>
      </categories>
      <tags>
        <tag>iTem2</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.创建数组的两个基本方式1234// 1. 使用Array构造函数let person = new Array()// 2. 使用字面量表示法let person = ['name', 'age'] 2. 判断是否为数组类型123456789// 1. 使用instanceof判断let num = [1, 3, 5, 7]console.log(num instanceof Array) // true// 2. constructor 判断console.log(num.constructor === Array) // true// 3. 现获取内部的属性，返回一个字符串，再利用call，达到检测数组的目的,综合考虑推荐这种写法console.log(Object.prototype.toString.call(num) === '[object Array]') // true// 4. Array.isArrayconsole.log(Array.isArray(num)) // true 3. 数组中的常用方法(只列出常用的) push() pop() unshift() shift() splice()1234567891011121314151617181920212223242526272829303132333435// push()方法可以接受任意参数，逐个添加到数组尾部，并返回添加后的数组长度，该数组也会修改原数组。let arr = [1]console.log(arr.push(2)) // arr =&gt; [1, 2]console.log(arr.push('three')) // arr =&gt; [1, 'three']console.log(arr.push(&#123; a: 3 &#125;)) // arr =&gt; [1, &#123; a: 3 &#125;]console.log(arr.push([2, 3])) // arr =&gt; [1, [2, 3]]// pop() 从数组末尾移除最后一项，减少数组的长度，然后返回移除的项，并且会改变原来的数组let brow = ['Google', 'Baidu', '360']console.log(brow.pop()) // brow =&gt; ['Google', 'Baidu']// shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。let arr = [1, 3, 5, 7]console.log(arr.shift()) // arr =&gt; [3, 5, 7]/* * splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 * array.splice(start, deleteCount, item1,...itemX) * start :必须 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始* 的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的* 元素。 * deleteCount 可选 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如* 果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 * item1...itemX 可选要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 */ let arr = [1, 2, 3, 4, 5, 6, 7]// 从第2位开始删除0个元素，插入“drum” arr.splice(2, 0, 'a') //arr =&gt; [1, 2, "a", 3, 4, 5, 6, 7]// 从第3位开始删除1个元素arr.splice(3, 1) //arr =&gt; [1, 2, 3, 5, 6, 7]// 从第2位开始删除1个元素，然后插入“temp”arr.splice(2, 1, 'temp') //arr =&gt; [1, 2, 'temp', 4, 5, 6, 7]// 从第0位开始删除2个元素，然后插入"a1","a2"和"a3"arr.splice(0, 2, 'a1', 'a2', 'a3') //arr =&gt; ['a1', 'a2', 'a3', 3, 4, 5, 6, 7]// 从第2位开始删除2个元素arr.splice(arr.length - 3, 2) // arr =&gt; [1, 2, 5, 6, 7]// 从第2位开始删除所有元素arr.splice(2) // arr =&gt; [1, 2] 4. 可能遇到的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 将数组中的数字相加求和let arr = [1, 2, 3, 4, 5, 6, 7]console.log(eval(arr.join('+')))// 模拟后端返回的数据格式let result = &#123; code: '200', data: [ &#123; id: 123, name: 'a1', age: 25 &#125;, &#123; id: 456, name: 'a2', age: 26 &#125;, &#123; id: 789, name: 'a3', age: 27 &#125; ]&#125;// 判断后端返回数据中是否存在id为456的数据const filter1 = function(id) &#123; let obj = [] const data = result.data data.forEach((item) =&gt; &#123; let id = item.id obj.push(id) &#125;) return obj.indexOf(id) &gt; -1 ? true : false&#125;filter1(456) // =&gt; truefilter1(4566) // =&gt; false// 获取id为456的数据const filterData = function (id) &#123; let obj = &#123;&#125; const data = result.data data.forEach((item) =&gt; &#123; let id = item.id obj[id] = item &#125;) return obj[id] ? obj[id] : []&#125;filterData(456) // =&gt; &#123;id: 456, name: "a2", age: 26&#125;filterData(4566) // =&gt; []]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue脚手架vue-cli配置多页面应用]]></title>
    <url>%2F2018%2F05%2F05%2Fvue%E9%A1%B9%E7%9B%AEwebpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[webpack常用插件 html-webpack-plugin // 生成一个html文件 clean-webpack-plugin // 清除dist文件夹中重复的文件 webpack-merger // 合并webpack配置文件 webpack-dev-server // 热启动 extract-text-webpack-plguin // 抽取样式文本 1.配置多入口123456789101112131415161718192021222324// utils.js// 查找符合特定规则的文件路径名var glob = require('glob')//获取多级的入口文件exports.getMultiEntry = function (globPath) &#123; var entries = &#123;&#125;, basename, tmp, pathname; glob.sync(globPath).forEach(function (entry) &#123; basename = path.basename(entry, path.extname(entry)); tmp = entry.split('/').splice(-4); var pathsrc = tmp[0] + '/' + tmp[1]; if (tmp[0] == 'src') &#123; pathsrc = tmp[1]; &#125; pathname = pathsrc + '/' + basename; // 正确输出js和html的路径 entries[pathname] = entry; &#125;); return entries;&#125; 2. 在webpack.base.conf.js中赋值给entry123456const utils = require('./utils')// 多页面设置入口文件const entries = utils.getMultiEntry('./src/' + config.moduleName + '/**/**/*.js');module.exports = &#123; entry: entries,&#125; 3. 构建生成多页面的HtmlWebpackPlugin配置12345678910111213141516// webpack.dev.conf.js webpack.prod.conf.js分别在webpack.dev.conf.js 和webpack.prod.conf.js中设置var pages = utils.getMultiEntry('./src/' + config.moduleName + '/**/**/*.html');for (var pathname in pages) &#123; var conf = &#123; filename: pathname + '.html', template: pages[pathname], // 模板路径 chunks: ['vendor', pathname], // 每个html引用的js模块 inject: true, // js插入位置 hash: true &#125;; webpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125;module.exports = webpackConfig 4. 简单的几步走，具体细节看项目代码使用vue脚手架vue-cli配置多页面应用]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Object]]></title>
    <url>%2F2018%2F02%2F01%2Fobject%2F</url>
    <content type="text"><![CDATA[1.创建对象的几种方法1.1创建对象的最简单的方法就是使用对象直接量1var emptyObj = &#123;&#125;; 1.2 通过new创建对象1var emptyObj = new Object(); 1.3 Object.create(prototype, [propertyObject])使用Object.create()创建一个新对象，其中第一个参数是对象的原型，第二个是可选参数，用于对对象的属性进行进一步的描述。propertyObject 为null时新创建的对象就不包括所有的属性和方法 var obj = Object.create(null) obj.toString =&gt; undefined Object.create应用场景(实现继承)1234567891011121314function Person() &#123;&#125;function Student() &#123;&#125; // 这样做的好处是修改子类的属性不会对父类造成影响，可以在Student实现自己的属性和方法，但有一点Object.create是ES5的时候才有的方法，不兼容低版本，如果想要使用Object.create可以事先判断一下Student.prototype = Object.create(Person.prototype)if (!Object.create) &#123; Object.create = function (proto) &#123; function N () &#123;&#125; N.prototype = proto; return N; &#125;&#125;// 对上面的继承进行扩展，有一种更加便利的方式;// 将Student原型对象中的构造函数指向PersonStudent.prototype.constructor = Person 对象中的getter setter方法1234567891011121314151617181920212223242526272829303132var objs = &#123; name: 'Bruce', get deelName() &#123; return this.name &#125;, set deelName(val) &#123; this.name = val &#125;&#125;// 获取属性值 objs.deelName =&gt; Bruce// 为对象属性赋值 objs.deelName = 'test'// 验证赋值=&gt; 'test'// objs.name =&gt; 'test'// 对象已有的属性添加特性描述var book = &#123; _year: 2004,&#125;Object.defineProperty(book, 'year', &#123; configurable: true, // 默认为true 是否可以配置（删除、修改、访问） enumerable: true, // 默认true 是否能枚举for-in writable: true, // 默认true 是否能修改属性的值 get: function() &#123; return this._year &#125;, set: function(newval) &#123; this._year = newval &#125;&#125;)// book.year =&gt; 2004// book.year = 2005// book.year =&gt; 2005]]></content>
      <categories>
        <category>Object</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum操作常用命令]]></title>
    <url>%2F2018%2F01%2F31%2Fyum-not%2F</url>
    <content type="text"><![CDATA[列出所有已安装的软件包1yum list installed yum针对软件包操作常用命令：1.使用YUM查找软件包1yum search 2.列出所有可安装的软件包1yum list 3.列出所有可更新的软件包1yum list updates 4.列出所有已安装的软件包1yum list installed 5.列出所有已安装但不在 Yum Repository 内的软件包1yum list extras 6.列出所指定的软件包1yum list 7.使用YUM获取软件包信息1yum info 8.列出所有软件包的信息1yum info 9.列出所有可更新的软件包信息1yum info updates 10.列出所有已安装的软件包信息1yum info installed 11.列出所有已安装但不在 Yum Repository 内的软件包信息1yum info extras 12.列出软件包提供哪些文件1yum provides]]></content>
      <categories>
        <category>yum</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F01%2F29%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.命令的基本格式命令 选项 参数 ls -a 全部文件/包括隐藏文件 ls -l 显示详细信息ls -d 查看目录属性ls -i 显示inodels -lh 显示文件的字节大小 rw -r - - r - - 文件类型 （ - 文件 d 目录 i软链接文件）rw- r - - r - -u所有者 g所属组 o其他人r 读 w写 x执行 2.目录处理命令根目录和家目录是两个不同的概念 mkdir -p 目录-p 递归创建 cd+enter 进入当前用户的家目录cd ~ 进入当前用户的家目录cd - 进入上次目录cd .. 进入上一级目录cd . 进入当前目录 相对路径：参照的是我当前的目录绝对路径：具体的目标路径 按连续两次tab键：命全补充和目录补全pwd：打印当前位置的工作路径 3.删除文件或目录rm -rf 文件/目录 -r 删除目录-f 强制 4.复制文件或目录cp -r 原文件或目录 目标目录 -p 连带文件属性复制 -d 若源文件是链接文件，则复制链接属性 -a 相当于pdr 5.剪切或者改名命令mv 源文件或者目录 目标目录 6.目录介绍根目录下的bin和sbin， usr目录下的bin和sbin，这四个目录都是用来保存系统命令的。bin和sbin的区分：bin： 任何用户都可以执行sbin：只有root用户才能执行boot: 启动目录dev: 特殊文件保存目录lib: 函数库目录sys 和 proc: proc和sys目录不能直接操作，这两个目录保存的是内存的过载点。usr：系统软件资源目录var：系统相关命令media met misc 空目录 7.文件搜索命令 文件搜索命令locate(执行没有命令执行时需要安装 yum install locate)locate 文件名在后台数据库中按文件名搜索，搜索速度更快 /var/lib/mlocatelocate命令所搜索的后台数据库 updated更新数据库/etc/updatedb.conf 配置文件 命令搜索命令whereis与which whereis 命令名搜索命令所在路径及帮助文档所在位置 -b: 只查找可执行文件-m:只查找帮助文件 which 命令名 搜索命令所在路径及别名 文件搜索命令find find 搜索范围 搜索条件find / -name filelog.log find 是在系统中搜索符合条件的文件名，如果需要匹配，s会用通配符匹配，通配符是完全匹配。 find / -iname filelog.log 加i忽略大小写 find / -user root 按照所有者搜索 Linux中的通配符 匹配任意内容？匹配任意一个字符[] 匹配任意一个中括号内的字符]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac环境下使用瓶子（Charles）抓包Https请求]]></title>
    <url>%2F2017%2F12%2F19%2FCharles%2F</url>
    <content type="text"><![CDATA[Charles 根证书配置1.选择 Charles 菜单“Help”-&gt;“SSL Proxying”-&gt;“Install Charles Root Certificate”2.接着会自动弹出‘钥匙串访问’，默认情况下 Charles Proxy CA证书不会被信任的，右键选择显示简介将证书修改为始终信任 SSL Proxying Settings选择菜单中“Proxy”-&gt;“SSL Proxying Settings…”添加使用通配符 Host Port ，表示抓取所有地址与端口的HTTPS请求 给手机安装证书打开Charles，在Menu选择Help &gt; SSL Proxying &gt; Install Charles Root Certificate on a Mobile Device or Remote Browse弹出一个弹框，根据提示使用手机访问地址： chls.pro/ssl 给手机安装证书 最后别忘了在手机中将瓶子证书设置为信任，不然请求就会一直返回unknown设置–&gt;通用–&gt;关于本机–&gt;证书信任设置把里面的那个Charles的证书设置为信任就可以了]]></content>
      <categories>
        <category>Charles</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>mac Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm常用操作]]></title>
    <url>%2F2017%2F11%2F17%2Fnvm%2F</url>
    <content type="text"><![CDATA[1.安装nvm命令github.com nvm wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 2.核实nvm是否安装成功，安装成功后执行命令返回’nvm’1command -v nvm 3.检查当前支持什么版本1nvm ls-remote 4.指定安装版本1nvm install vx.x.x 5.安装最新稳定版本1nvm install stable 6.删除某版本的node12nvm uninstall 4.4.0nvm uninstall default 7.nvm使用default的alias来实现默认版本,执行命令1nvm alias default vx.x.x 8.查看当前已经安装的版本1nvm ls 9.以指定版本执行脚本1nvm use v8.8.1 app.js 10.卸载nvm1rm -rf ~/.nvm 11.切换至x.x.x版本1nvm use vx.x.x 12.查看正在使用的版本1nvm current]]></content>
      <categories>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>mac nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac电脑终端使用scp上传/下载文件/文件夹]]></title>
    <url>%2F2017%2F11%2F15%2Fremote-scp%2F</url>
    <content type="text"><![CDATA[1.从服务器下载文件到本地电脑1scp -r remote_username@remote_ip:remote_folder local_folder 例如： 1scp -r root@106.xx.xxx.xx:/root/www/file /Desktop/folder 2.从本地上传文件到服务器1scp -r local_folder remote_username@remote_ip:remote_folder 例如： 1scp -r /Desktop/folder root@106.xx.xxx.xx:/root/www/file 3.上传和下载文件就是把这种格式来回调换一下]]></content>
      <categories>
        <category>scp</category>
      </categories>
      <tags>
        <tag>scp</tag>
        <tag>mac scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用mac终端将本地文件上传到服务器上]]></title>
    <url>%2F2017%2F11%2F15%2Fremote-shell%2F</url>
    <content type="text"><![CDATA[1.打开本地终端，使用菜单中Shell2.使用菜单中Shell 选择 “新建远程连接”3.进入“新建远程连接控制面板”后左侧服务选择“安全文件传输（sftp）”右侧服务器端添加自己的服务器连接ip地址，同时输入要使用的“用户”身份选择登录。4.开始上传本地文件，上传文件之前需要把文件在本地进行压缩 put 本地文件的地址链接 要上传到服务器的位置 1put Desktop/www/file.zip /www/file 5.在服务上对已上传的压缩文件进行解压 切换到文件当前目录下执行命令： 1unzip file.zip]]></content>
      <categories>
        <category>mac</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>mac shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express 路由(Router)]]></title>
    <url>%2F2016%2F10%2F29%2Fexpress-router%2F</url>
    <content type="text"><![CDATA[基本路由1.路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。路由定义采用以下结构： 1app.METHOD(PATH, HANDLER) 其中：app 是 express 的实例。METHOD 是 HTTP 请求方法。PATH 是服务器上的路径。HANDLER 是在路由匹配时执行的函数。 2.在根路由 (/) 上（应用程序的主页）对 POST 请求进行响应：123app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user');&#125;); 有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。在以下示例中，无论您使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法，都将为针对“/secret”的请求执行处理程序。 1234app.all('/secret', function (req, res, next) &#123;console.log('Accessing the secret section ...');next(); // pass control to the next handler&#125;); 路由路径路由路径与请求方法相结合，用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。 Express 使用 path-to-regexp 来匹配路由路径；请参阅 path-to-regexp 文档以了解定义路由路径时所有的可能性。Express Route Tester 是用于测试基本 Express 路由的便捷工具，但是它不支持模式匹配。 以下是基于字符串的路由路径的一些示例。 此路由路径将请求与根路由 / 匹配。 123app.get('/', function (req, res) &#123; res.send('root');&#125;); 此路由路径将请求与 /about 匹配。 123app.get('/about', function (req, res) &#123; res.send('about');&#125;); 字符 ?、+、* 和 () 是其正则表达式同应项的子集。基于字符串的路径按字面理解连字符 (-) 和点 (.)。 express.Router使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。 以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。 在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容： 12345678910111213141516var express = require('express');var router = express.Router();// middleware that is specific to this routerrouter.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// define the home page routerouter.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// define the about routerouter.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 接着，在应用程序中装入路由器模块：123var birds = require('./birds');...app.use('/birds', birds); 此应用程序现在可处理针对 /birds 和 /birds/about 的请求，调用特定于此路由的 timeLog 中间件函数。]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>express.Router</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue filter]]></title>
    <url>%2F2016%2F10%2F10%2Fvue-filter%2F</url>
    <content type="text"><![CDATA[Vue过滤器的基本使用html部分123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--插值中的表达式--&gt; &lt;input type="text" v-model="msg"&gt; &lt;h2&gt;&#123;&#123; msg ? 'YES' : 'NO' &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; msg.split('').reverse().join('') | uppercase &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; number + 1 | currency '₫' 0 &#125;&#125;&lt;/h2&gt; &lt;!--自定义过滤器--&gt; &lt;h2&gt; &#123;&#123; filterParam | customFilter&#125;&#125;&lt;/h2&gt; &lt;!-- 1.limitBy - test 2.限制只显示数字中前两条数据 --&gt; &lt;ul&gt; &lt;li v-for="item in dataArray | limitBy 2"&gt;name: &#123;&#123; item.name &#125;&#125;----age: &#123;&#123; item.age &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 1.filterBy - test 2.过滤出对象中name属性字段含有‘Chuck’值的数据，并且只显示该数据 3.in 后面可以跟多字段进行搜索 --&gt; &lt;ul&gt; &lt;li v-for="item in dataArray | filterBy 'Chuck123' in 'name' 'temp'"&gt;name: &#123;&#123; item.name &#125;&#125;----age: &#123;&#123; item.age &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; js部分12345678910111213141516171819202122/** * 1.split 将字符串分割成数组 * 2.filter 接受两个参数，第一个是自定义名称，第二个是一个函数，并将值作为参数使用最后返回处理后的值 * 3.reverse 用于颠倒数组之前的顺序 * join 将数组按照指定分隔符进行分割，并返回一个字符串 * */ Vue.filter('customFilter', function(value) &#123; return value.split('').reverse().join('') &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'world', number: 148547, filterParam: 'small text!', dataArray: [ &#123;'name': 'Bruce', 'age': 1&#125;, &#123;'name': 'Chuck', 'age': 2, 'temp': 'Chuck123'&#125;, &#123;'name': 'Jack', 'age': 3&#125;, ] &#125; &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-filter</tag>
      </tags>
  </entry>
</search>
